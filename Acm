注意，如果数组越界了什么错误都有可能发生，TLE、WA之类的。
一般ACM或者笔试题的时间限制是1秒或2秒。
在这种情况下，C++代码中的操作次数控制在 107∼108107∼108 为最佳。

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

n≤30, 指数级别, dfs+剪枝，状态压缩dp
n≤100 => O(n3)，floyd，dp，高斯消元
n≤1000 => O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford
n≤10000 => O(n∗n√)，块状链表、分块、莫队
n≤100000 => O(nlogn)=> 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树
n≤1000000 => O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa
n≤10000000 => O(n)，双指针扫描、kmp、AC自动机、线性筛素数
n≤10^9 => O(n√)，判断质数
n≤10^18 => O(logn)，最大公约数，快速幂，数位DP

-3.定义全局数组就是初始化下标0~N-1的位置都是0！！！！！！

-2.记得在数据初始化的时候(比如要全部数据归0)要用memset函数
具体用法:
memset(room,0,sizeof(room))(room是一个数组的名字，第二个0是所有数据初始化为0，第三个则是数组的长度)
当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 
memset(a, 0x3f, sizeof(a)) 给数组赋 0x3f3f3f3f的值来代替。

-1.fabs()是求绝对值的函数,abs()也是求绝对值的函数，但是fabs是对浮点数求绝对值,abs是对整数求绝对值，头文件是#include<algorithm>

0.strcmp(字符串，字符串)==0(比较两个字符串，等于0则代表两个字符串相等)

1.有些一开始要初始化0的数据最好放在循环里面赋值，不然会有奇奇怪怪的错误。

2.注意最后输出的格式，若是多个数据中间有空格输出，注意判断是否为最后一个数据，是的话后面就不用空格，不然就会有presentation error！！！

3.#include <cmath>用一些开根号之类的东西会用到，求平方，立方，开平方，开立方等都可以用pow函数，例如x的开立方:pow(x,1.0/3)。

4.#include <cstring>有字符串的时候就加。在多次输入字符数组的时候，可以用gets(a)，也是用cstring这个头文件，例如定义char a[101]，想多次输入字
符则可以用while(gets(a))

5.Cin.getline(输入的字符数组, 字符最大个数, 终止字符);
这个终止字，最后加上一个终止字符，再按下回车，就会终止输入，这一点在特定程序中可以达到很好的效果。
当然，cin.getline的括号中也可以不要终止字符，不要终止字符符非常好用，就是定义一个字符，输入完你要的字符串的结果就是输入一行字符串，按下回车就代表输入完成，而带有终止字符的字符串可以换行输入。

6.getchar():正常情况下是用来吃掉一个回车(注意这个东西在有字符串的题目里面非常经常要用，很多字符串的题目没有这个函数输出不了结果）

7.__gcd-最大公约数
__gcd(x,y)是求x和y的最大公约数，是algorithm库中的函数，所以头文件为#include<algorithm>

8.每次循环记得要把一些计数的数据初始化为零，不然会报答案错误！！！
 
9.C中的汉字用“机内码”，一个汉字两字节，最高位都是1.
统计字符串中的汉字个数的关键在于：
汉字机内码在计算机的表达方式的描述是,使用二个字节，每个字节最高位一位为1. 
计算机中,补码第一位是符号位,1 表示为负数,所以 汉字机内码的每个字节表示的十进制数都是负数　　
所以这题也就可以简化为输入字符串判断其中字符转化为十进制数是否小于零.
注意:汉字是有两个小于零的字符组成,所以在统计结果的时候就要将count除以2了.

10.string s是定义了一个名字为s的字符串（注意不是字符！）要输入字符串只需要cin>>s即可，不用像char那样输入字符得一个个输入。要读取字符串的元
素主要一个个读取s[i]就可以了，但是string计算字符长度和char不一样，char是用strlen（），string是用s.length().

11.sort（）为排序用的一个函数，默认从小到大排序。包含在头文件#include<algorithm>中，具体的用法是：括号内可以填三个数，第一个是要排序数组
的起始位置，第二个是结束的地址，第三个是排序的方法，可以不写就默认是从小到大。例子：
sort(a,a+m,cmp);（a就是数组a[0]开始，数组长度就是m，如果如此题数组是一个对象数组有不同的数据，排序方法可以定义一个函数来表达）
bool cmp(rice a,rice b)
{
    return a.p<b.p;（对比对象数组中p的大小，大部分函数都是布尔类型，小于号则是从小到大排序，大于号则是大到小排序）
}

12.记住如果用printf输出的时候，不能加上&变量，不然会恒输出0！！！！

13.STL：STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)
容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。
算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function template.
迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator–等指针相关
操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是
一种迭代器。
(1).容器：(可以把它看做是一个类,所有容器的对象在使用各个方法(也可以看做成员函数)的时候只要用对象.方法名称来调用就可以了)
数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。
常用的数据结构：数组(array) , 链表(list), tree(树)，栈(stack), 队列(queue), 集合(set),映射表(map), 根据数据在容器中的排列特性，这些数据分为序列式容
器和关联式容器两种。

序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。
关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的
逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器
 Map/multimap容器

string容器：(大部分返回值都是string类型)
(1)string是一个类封装了char*，可以理解为string内有一个指针，指向一串内存空间。
封装了很多实用成员的方法：查找find,拷贝copy,删除delete,替换replace,插入insert。(只要调用这些方法就能直接调用这些功能，就不用自己一个个去写，也
不用考虑内存释放和越界的问题)
注意""和''的区别：双引号中间的数据视作字符串，单引号中间的数据视作字符。
在有头文件#include<string>之后，没办法用char类型的函数，例如strcmp之类的，要多加一个头文件#include<string.h>
用户输入一个string类型要用getline<cin,str>来使用！！！！！！！！

(2)初始化
string s1;(调用无参构造)
string s2 (10,'a');
string s3("asdfgh")
string s4(s3)(拷贝构造)

(3)赋值操作
string s1;
string s2("appp");
s1="abcdef"
cout<<s1<<endl;
s1=s2;
cout<<s2<<endl;
//成员方法assign
s1.assign("jkl")
cout<<s1<<endl;
//为了能访问字符串，要重载[]操作符
for(int i=0;i<s1.size();i++){
cout<<s1[i]<<" ";
}
cout<<endl;
//或者用at成员函数
for(int i=0;i<s1.size();i++){
cout<<s1.at(i)<<" ";(要访问at弄出来的数组，直接写s1.at(0)就可以访问第一个字符了)
}
cout<<endl;
重载[]和at的区别在于如果访问越界，[]直接没了，at会抛出异常out_of_range

(4)string的拼接操作
1.string& operator+=(const string& str);(重载+=运算符):
  string s1="abcd";
  string s2="1111"
  s1+="abcd";
  s1+=s2;
cout<<s1;


2.string& append(const string &s)(在末尾加上字符)
string s3="2222";
s2.append(s3);
cout<<s3<<endl;

(5)string的查找和替换
int find(const string& str,int pos=0) const;(查找str第一次出现的位置，从pos开始查找)
int rfind(const string& str,int pos=npos) const;(查找str最后一次出现的位置，从pos开始找)
string s="abcdefghfgjkl";
int pos=s.find("fg");(会返回fg的位置,会返回5)
cout<<pos<<endl;
pos=s.rfind("fg");(返回8)
替换(replace方法):
string s="abcdefg";
s,replace(0,2,"111")(0是起始位置，2是索引开始的2个字符，"111"是替换成啥子东西)
cout<<s<<endl;(输出111cdefg)

(6)string的比较操作
成员函数compare在>时返回1，在<时返回-1，==时返回0,通过阿斯克码值来判断
string s1="abcd";
string s2="abce";
if(s1.compare(s2)==0)
cout<<"相等"<<endl;
else
cout<<"不相等"<<endl;

(7)string子串
成员函数substr:string substr(int pos=0,int n=npos) const;(返回由pos开始的n个字符组成的字符串,npos默认最后一个字符)
string s="abcdefg";
string str = s.substr(1,3)(3是1开始的3个字符的意思，而不是终止位置)
cout<<str<<endl;

(8)插入和删除
成员函数insert(有两个参数)和erase(两个参数)
string s="abcdefg";
s.insert(3,"111");(从第3个位置插进去，也就是在c和d之间插入)
cout<<s<<endl;(输出结果为abc111defg)
s.erase(0,2);(从位置0开始的两个字符)
cout<<s<<endl;(输出的是c111defg)

vector容器(一般都在尾部进行操作，不然效率会很低)
定义：也就是一个动态数组，可变数组，vector也是一种单口容器.(可以看作是栈去理解，但是和stack容器又有区别。所以删除和插入都是在尾部或者
说顶部去操作)，v.begin()是返回一个迭代器，迭代器相当于是指针，指向容器中的第一个元素，v.end()也是一个迭代器，也是一个指针指向最后一个
元素的后一位(这句话很关键注意不是指向最后一个元素，和栈一模一样)。v.rbegin()指向容器的最后一个元素，v.rend()指向第一个元素的前一个位置。
vector动态增长的基本原理:当插入新元素时，如果空间不足，那么vector会重新申请更大的内存空间，将原空间的数据拷贝到新空间，释放旧空间的
数据，再把新元素插入到新申请的空间。

(1)初始化
1.vector<T> v;  (采用模板实现类实现，默认构造函数)
例：
vector<int>v1;(默认构造)
2.vector(v.begin(),v.end());(将v[.begin(),.end()]区间中的元素拷贝给本身)
例：
int array[]={2,3,4,1,9};
vector<int>v1(arr,arr+sizeof(arr)/sizeof(int))  (arr就是开始，后面就是结束，sizeof(arr)/sizeof(int)就是求后面数据的长度)
vector<int>v2(v1.begin(),v1.end());  (用容器v1的开始和结束定义)
3.vector(n,elem)(构造函数将n个elem拷贝给本身)
vector<int>v3(v2);  (将v2拷贝给v3)
若要遍历该容器：
void printVector(vector<int>& v){(后面操作会用到遍历容器，到时候直接写函数名调用此功能)
for(vector<int>::iterator it = v.begin();it!=v.end();it++)(iteractor是迭代器的意思，it是用户定义的迭代器变量){
cout<<*it<<" ";(用户自定义迭代器变量it前面要加*！！！！)
}
cout<<endl;
}
(2)赋值
成员函数：1.assign(n,elem)(将n个elem拷贝赋值给本身)    2.assign(begin,end)(另一个容器的开始和结束)   3.swap(vec)(将vec与自身的元素互换)
例：
int array[]={2,3,4,1,9};
vector<int>v1(arr,arr+sizeof(arr)/sizeof(int))
vector<int>v2;
v2.assign(v1.begin(),v1.end());(第2个方法)
vector<int>v3;
v3=v2;(重载=来赋值)
int array1[]={20,30,40,10,90};
vector<int>v4(arr,arr+sizeof(arr)/sizeof(int))
v4.swap(v1);(v4和v1的值进行交换)

(3)大小操作
成员函数：1.size()(返回容器中元素的个数)    2.empty()判断容器是否为空   3.resize(int num) (重新定义容器的长度为num，如果容器变长，则以默认值填充
新位置。如果容器变短，则末尾超出容器长度的元素被删除)
4. resize(int num,elem) (重新定义容器的长度为num，如果容器变长，则以elem填充新位置。如果容器变短，则末尾超出容器长度的元素被删除)
5.capacity()(容器的容量)
6.reserve(int len)(容器预留len个元素长度，预留位置不初始化，元素不可访问)
int array[]={2,3,4,1,9};
vector<int>v1(arr,arr+sizeof(arr)/sizeof(int))
cout<<"size :"<<v1.size()<<endl;(会返回5这个值)
if(v1.empty()==true)(empty返回true或者false，空返回true,不空返回false)
cout<<"空"<<endl;
v1.resize(2);
printVector(v1)(调用之前的遍历的函数)（遍历的函数会输出2，3）
v1.resize(6)
printVector(v1)(输出 2，3，0，0，0，0,默认值是0)
v1.resize(7,1)(多出来的用1这个值赋予)
printVector(v1)(2,3,0,0,0,0,1)
cout<<v1.capacity()<<endl;(容量，元素个数可以小于等于容量但不可以大于容量)
cout<<"size :"<<v1.size()<<endl;(元素个数)

(4)数据存取操作
1.成员函数：at(int index)(返回索引index所指的数据，如果越界，抛出out_of_range异常)  2。front() (返回容器中的第一个数据元素，注意和begin()区分，begin()返回的
是第一个迭代器，而不是第一个元素). 3.back()  (返回最后一个数据元素)
int array[]={2,3,4,1,9};
vector<int>v1(arr,arr+sizeof(arr)/sizeof(int))
for(int i=0;i<v1.size();i++)
cout<<v1.at(i)<<endl;(用这个方法和printVector一样能够遍历数据，而且更安全)
cout<<v1.front()<<endl;(2)
cout<<v1.back()<<endl;(9)

(5)插入和删除
成员函数：1.push_back(elem)(尾部插入元素elem)  2.pop_back()(删除最后一个元素)  3.insert(const_iterator pos,int count,elem)(迭代器指向位置pos
插入count个元素elem)   4.erase(const_iterator pos)(删除迭代器指向的数据)   5.erase(const_iterator start,const_iterator end)(删除start到end之间数据)
6.clear()(删除所有元素)
vector<int> v;
v.push_back(10);
v.push_back(20);0
v.insert(v.begin(),30)(用第三个方法，意思是再头指针的地方插入30这个数据)(v变成 30 10 20 )
v.insert(v.begin() + 2,100);(能加2的原因是vector支持随机访问，也就是迭代器能随意加来访问不用位置信息)
printVector(v)(结果是30 10 100 20)
v.erase(v.begin())  (删除第一个数据)
printVector(v)
v.erase(v.begin()+1,v.end())
printVector(v)(还剩下10这个元素)
v.clear();全没了

(6)排序sort(v.begin(),v.end());


(7)用swap收缩容器大小
vector<int> v;
for(int i=0;i<10000;i++)
v.push_back(i)
cout<<v.size()<<endl;
cout<<v.capacity()<<endl;
(第一个是输出样本容量10000，第二个是输出容器大小大于10000)
v.resize(10)
cout<<v.size()<<endl;
cout<<v.capacity()<<endl;
(第一个是输出样本容量10，第二个是输出容器大小也就是第一次输出的那个大于10000的值，那么这样就会浪费很多容器的空间，要用swap收缩空间)
vector<int>(v).swap(v);
cout<<v.size()<<endl;
cout<<v.capacity()<<endl;
(输出的size和capacity都是10)

(8)unique函数
作用:去重复，即是不重复元素替换掉重复元素的位置，在使用该函数之前要先用sort排序，重复的元素会返回到容器后面的位置，且会返回不重复序列的
最后一个元素的下一个元素。
unique(v.begin(),v.end());(返回一个迭代器，返回的是去重复后容器中不重复序列的最后一个元素的下一个元素)


deque容器：
和vector相似，vector是单口容器，deque是双口容器，deque对于头部和尾部的操作一样方便，指定位置插入会导致数据元素的移动，降低效率。

(1)初始化
deque<int> d1;
deque<int> d2(10,5);(十个5来初始化)
deque<int> d3(d2.begin(),d2.end())
deque<int> d4(d3)
遍历：
for(deque<int>::iterator it=d4.begin(),it!=d4.end();it++){
cout<<*it<<endl;
}

(2)赋值
deque<int> d1;
deque<int> d2;
deque<int> d3;
1.d1.assign(10,5)(十个5的数据)
2.d2.assign(d1.begin(),d1.end())(将[begin,end)区间里面的数据拷贝给本身)
3.d1=d2
d1.swap(d2)(交换两个空间的元素)

(3)大小操作
d.size()(返回容器中元素个数)
d.empty()(判断容器是否为空)
d.resize(num)(重新指定容器为长为num的长度，边长则以默认值填充新的位置，变短则超出的元素被删除)
d.resize(num,elem)(重新指定容器为长为num的长度，边长则以elem值填充新的位置，变短则超出的元素被删除)

(4)双端插入和删除操作
d.push_back(elem)(在容器尾部添加一个数据elem)
d.push_front(elem)(在容器头部添加一个数据elem)
d.pop_back()(在容器尾部删除一个元素)
d.pop_front()(在容器头部删除一个元素)

(5)数据存取
d.at(i)(返回索引i所指的数据，如果越界则会抛出out_of_range)
d.front()(返回第一个数据)
d.back()(返回最后一个数据)

stack容器(和vector有一定区别)
规则:先进后出！！！就是栈，有栈顶和栈底，向栈中添加元素叫做压栈，删除元素叫做出栈。top()可以返回栈顶的元素。栈不能遍历，不支持随机存取
只能通过top()从栈顶获取和删除元素。不提供迭代器。这就是和vector的区别。

(1)初始化和之前的都差不多，懒得打，只是没有了begin()和end()那种初始化的方法

(2)操作
s1.push(10)(压栈)
s1.pop()(出栈)
s1.top(返回栈顶元素)
s1.empty()(判断是否为空)
s1.size()(返回栈的大小)
打印元素
while(!s1.empty()){
cout<<s1.pop()<<endl;
s1.pop();
}

queue容器：(也不提供迭代器)
在一端插入，在另一端删除，规则：先进先出，后进后出。

优先队列：
默认是大顶堆，就是排序从大到小。
(1)构造函数
queue<T> q

(2)存取，插入和删除
q.push(elem)(往队尾添加元素)
q.pop()(从队头移除第一个元素)
q.back()(返回最后一个元素)
q.front()(返回第一个元素)
打印：
while(q.size()>0){
cout<<q.front()<<endl;(输出队头元素)
q.pop；(删除队头元素)
}
(3)大小操作(不说了nmd都一样)
q.empty()
q.size()

list容器：（可以与数据结构中的链表一起理解）
定义：由系列的节点组成，节点包含两个域，一个指针域一个数据域，链表的内存是非连续的，添加和删除元素的时间复杂度都是常数项，不需要移动元素。
只要你拿到第一个节点，相当于拿到了整个链表。链表只有在需要的时候，才分配内存。只有当指针指向为空的时候，证明链表结束了
(1)
set/multiset容器(头文件#include<set>)
set/multiset的特性是所有元素会根据元素的值自动进行排序，set是以红黑树(一种二叉树)为底层机制，其查找的效率非常好。set容器中是不允许有重复
元素，multiset允许重复元素。不能用迭代器set改变元素的值。

(1)初始化(没有push或者pop，只有insert)
set<int> s1;
s1.insert(7)；
s1.insert(2);
s1.insert(4);
s1.insert(5);
s1.insert(1);
for(set<int>::iterator it=s1.begin();it!=s1.end();it++){
cout<<*it<<" ";(输出结果为1 2 4 5 7，set容器会自动排序)
}
cout<<endl;

(2)赋值操作
1.重载了=号    2.swap(set)交换两个集合容器、
(3)大小操作
1.size()返回容器中元素的数目  2.empty()判断容器是否为空

(4)插入和删除
1.insert(elem)   2.clear()清空所有元素  3.erase(pos)删除pos迭代器所指的元素，返回下一个元素的迭代器  4.erase(begin,end)删除区间[begin,end)(注意
这里是小括号)所有元素，返回下一个元素的迭代器   5.erase(elem)删除容器中值为elem的元素。

(5)查找操作(最重要！！！)
1.find(key);查找键key是否存在，若存在，返回该键元素的迭代器，若不存在，返回map.end().
set<int> s1;
s1.insert(7)；
s1.insert(2);
s1.insert(4);
s1.insert(5);
s1.insert(1);
set<int>::iterator ret=s1.find(4);
if(ret==s1.end()) (因为没有找到返回end()迭代器)
cout<<"没有找到"<<endl;
else
cout<<*ret<<endl;

2.lower_bound(keyElem) 返回第一个key>=keyElem(你指定的值)元素的迭代器。
set<int> s1;
s1.insert(7)；
s1.insert(4);
s1.insert(5);
s1.insert(1);
set<int>::iterator ret=s1.lower_bound(2);
if(ret==s1.end()) 
cout<<"没有找到"<<endl;
else
cout<<*ret<<endl;(输出4，因为虽然没有2但是4>=2所以被lower_bound找到)

3.upper_bound(keyElem)返回第一个key>keyElem元素的迭代器
set<int> s1;
s1.insert(7)；
s1.insert(2);
s1.insert(4);
s1.insert(5);
s1.insert(1);
set<int>::iterator ret=s1.upper_bound(2)
cout<<*ret<<endl;(这个有2但是因为是upper_bound要大于2，所以还是找到4)

4.equal_range(keyElem)  返回容器中key与keyElem相等的上下限的两个迭代器(返回upper_bound和lower_bound值)
set<int> s1;
s1.insert(7)；
s1.insert(2);
s1.insert(4);
s1.insert(5);
s1.insert(1);
pair<set<int>::iterator,set<int>::iterator>myret=s1.equal_range(2);   (因为equal_range返回两个迭代器，所以用pair容器，且pair里面的两个迭代器
都要是set容器的迭代器)
if(myret.frist==s1.end()){
cout<<"没有找到"<<endl;
}else
cout<<*(myret.frist)<<endl;(这个返回的为2)
if(myret.second==s1.end()){
cout<<"没有找到"<<endl;
}else
cout<<*(myret.second)<<endl;(这个返回为4)

补充上面pair对组的用法:
pair将一对值组合成一个值，这一对值可以是具有不同的数据类型，两个值可以分别用pair的两个公有函数frist和second访问。
例：
初始化：
(1)
pair<int,int>pair1(10,20);
cout<<pair1.frist<<endl;
cout<<pair1.second<<endl;()
(2)
pair<int,string>pair2=make_pair(10,"aaa")
cout<<pair2.frist<<endl;
cout<<pair2.second<<endl;

(6)set更改默认顺序(set默认从小到大)
class mycompare{
public:
bool operator()(int v1,int v2){
return v1>v2;
};
int main(){
set<int,mycompare> s1;(mycompare是一个类类型，可以实现从大到小排序)
s1.insert(7)；
s1.insert(2);
s1.insert(4);
s1.insert(5);
s1.insert(1);
}

map/multimap容器
特性：map具有键值和实值，所有元素根据键值自动排序。pair的第一元素被称为键值，第二元素被称为实值(和py的字典很像)(数据要通过pair输入到map
容器里面！！！因为有两个值)

(1)初始化
map<T1,T2> mapTT;(默认构造函数)
map<int,int>mymap  (第一个参数int是key的类型，第二个参数int是value的类型)

(2)插入元素操作
1.insert();
map<int,int>mymap;
第一种方式：
mymap.insert(pair<int,int>(10,10));  (要创建一个pair放进去) 
第二种方式：
mymap.insert(make_pair(20,20))
第三种：(比较少见)
mymap.insert(map<int,int>::value_type(30,30))
第四种：(最常用)
mymap[40]=40;(第一个40为key,第二个为value，如果发现此key值已经存在了，则会修改相应的value)
cout<<mymap[60];(输出0)  (如果用[]的方式访问map中一个不存在的key，那么map将会把这个访问的key插入到map中)
cout<<mymap[60];(输出60 0)
打印：(通过迭代器)
for(map<int,int>::iterator it=mymap.begin();it!=mymap.end();it++){
//it取出来的是一个pair
cout<<it->frist<<it->second<<endl;(key和value)
}


list容器


14.差分前缀和
前缀和:
1.如何求前缀和:s[i] = a[1]+a[2]+... 等价于for(int i = 1;i <= n; i++)
2.前缀和的作用(s[i] = s[i-1] + a[i]):快速求出原数组内一段区间的和，时间复杂度是常数。比如说求[l,r]这个区间的数组和，就是求s[r] - s[l-1]。(减去1是
因为要求[l,r]区间的和，肯定要把l算进去的，如果是s[r]-s[l]的话就把l这个点的值剪掉了，所以必须是s[r] - s[l-1])
具体实现：for (int i = 1; i <= n; i ++ ){
	cin >> a[i];
	s[i] = s[i - 1] + a[i];
                }
前缀和的优势：输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。
我们很容易想出暴力解法，遍历区间求和。这样的时间复杂度为O(n*m)，如果n和m的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法
来做的话就能够将时间复杂度降到O(n+m),大大提高了运算效率。这样，对于每个询问，只需要执行 sum[r]-sum[l-1]。输出原序列中从第l个数到第r
个数的和的时间复杂度变成了O(1)。我们把它叫做一维前缀和.
二维前缀和:
1.前缀和的求法s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
2.计算二维中一块区域的和:s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1].(x2>=x1,y2>=y1)
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 1010;
int a[N][N], s[N][N];

int main()
{
  int m, n, q;
  cin >> n >> m >> q;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      cin >> a[i][j];
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

  while (q--)
  {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    cout << s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] << endl;
  }
}
差分：
作用:差分就是给定一个长度为n的数列，每次可以选择一个区间[l,r]，使下标在这个区间的数都加一个常数或者都减一个常数。
b[i]=a[i]-a[i-1](b[]就是差分数组，a[]就是前缀和数组)
a[i]-a[i-1]是b[i]的差分，b[i]是a[i]的前缀和：a[i]=b[1]+b[2]+b[3]+b[4]....b[n].（易证）简单来说，给定一个数组，我们要算一个区间加减上一个常数
我们会用到差分数组，然后我们把差分数组求其前缀和，就可以得到我们想要的加减常数后的数组了。
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;
const int N = 100010;
int a[N], b[N]; (记住b是差分数组，a是输入的数组，全体要记住b是差分数组去做)
void insert(int l, int r, int c)
{
  b[l] += c;
  b[r + 1] -= c;
}

int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> a[i];
  for (int i = 1; i <= n; i++)
    insert(i, i, a[i]); (这个的目的是构造差分数组，因为一开始定义全局数组b初始化为0，l=i，r=i，c=a[i]故可以看作是在差分数组里给第i的位置赋予了a[i]
的值，且没有改变b是差分数组的性质)

  while (m--) (m是给一个区间加减一个常数m次)
  {
    int l, r, c;
    cin >> l >> r >> c;
    insert(l, r, c);
  }
  for (int i = 1; i <= n; i++)
    b[i] += b[i - 1]; (差分数组给自己求前缀和就是a[l]到a[r]加上一个常数c的结果)
  for (int i = 1; i <= n; i++)
    cout << b[i] << ' ';
}
差分序列经典题目color the ball：
N个气球排成一排，从左到右依次编号为1,2,3....N.每次给定2个整数a b(a <= b),lele便为骑上他的“小飞鸽"牌电动车从气球a开始到气球b依次给每个气
球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？
Input：
每个测试实例第一行为一个整数N,(N <= 100000).接下来的N行，每行包括2个整数a b(1 <= a <= b <= N)。 
当N = 0，输入结束。
Output：
每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。
Sample Input：
3
1 1
2 2
3 3
3
1 1
1 2
1 3
0
Sample Output：
1 1 1
3 2 1

#include<bits/stdc++.h>
using namespace std;
int main(){
	int a,b,n;
	while(cin>>n&&n){
		long long int s[100010]={0};
        for(int i=1;i<=n;i++)
        {
            cin>>a>>b;
            s[a]++;
            s[b+1]--;
        }
        for(int i=1;i<=n;i++)
        {
            s[i]+=s[i-1];
            if(i!=n)
            cout<<s[i]<<" ";
            else
            cout<<s[i]<<endl;
	}
}
}
二维差分:(给矩阵的一段范围加上一个常数)
通过原矩阵a[i][j]更新差分矩阵b[i][j],a数组是b数组的前缀和。
差分矩阵更新的模板:(x1<x2,y1<y2)
b[x1][y1] += c;
b[x2+1][y1] -= c;
b[x1][y2+1] -= c;
b[x2+1][y2+1] += c;

模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;
const int N = 1010;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
  b[x1][y1] += c;
  b[x1][y2 + 1] -= c;
  b[x2 + 1][y1] -= c;
  b[x2 + 1][y2 + 1] += c;
}

int main()
{
  int n, m, q;
  cin >> n >> m >> q;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      cin >> a[i][j];
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      insert(i, j, i, j, a[i][j]);

  while (q--)
  {
    int x1, y1, x2, y2, c;
    cin >> x1 >> y1 >> x2 >> y2 >> c;
    insert(x1, y1, x2, y2, c);
  }
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
  for (int i = 1; i <= n; i++)
  {
    for (int j = 1; j <= m; j++)
    {
      cout << b[i][j] << ' ';
    }
    cout << endl;
  }
}

二分查找法：
使用前提:数组已经按升序排列。
基本原理:首先要查找的元素与数组中间元素比较。
 (1)如果要查找的元素小于中间元素，只需要在数组的前一半元素中继续查找。
 (2)如果要查找的元素等于中间元素，成功结束。
 (3)如果要查找的元素大于中间元素，只需要在后一半元素中继续查找
模板:

最后还是觉得这个二分比较适合我：
int l = 0;
int r = n-1;
while(l<=r)
{
   int mid = l+r>>1;
   if(a[mid] == target)
   return mid; 
   else if(a[mid]<target)
   l = mid + 1;
   else 
   r = mid - 1; 
}
return -1 //没找到



求重复出现的数字的范围:
using namespace std;
const int N=100010;
int n,q,a[N];
int main()
{
int k;
cin >> n >> q;
for (int i = 0; i < n; i++)
{
cin >> a[i];
}
while (q–)
{
cin >> k;
int left = 0, right = n - 1, mid;
while (left < right)
{
mid = (left + right) / 2; //这个没有+1的就是求最小值的模板
if (a[mid] >= k)
right = mid;
else
left = mid + 1;
}
if (a[left] != k)
cout << “-1 -1” << endl;
else
{
cout << left << ” “;
int left = 0, right = n - 1;
while (left < right)     //这个有+1的即使求最大值的
{
int mid = (left + right + 1) / 2; (记住在做<=的时候，mid=left+right+1一定要加上1，不然会死循环，所以如果确定只有唯一一个数，最好用>=)
if (a[mid] <= k)
left = mid;
else
right = mid - 1;
}
cout << left << endl;
}
}
}
浮点数二分(不用考虑边界问题)
题目：求一个数n的三次方根。
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;
int main()
{
  double n;
  cin >> n;
  int l = -10000, r = 10000, mid; (l和r看题目给的数据范围)
  while (r - l > 1e-8)
  {
    mid = (l + r) / 2;
    if (mid * mid * mid >= n) (不用考虑边界问题)
      r = mid;
    else
      l = mid;
  }
  printf("%lf",l);
}
二分答案：
二分答案，就是用二分的方法，在可能的答案区间里找出问题的答案，二分答案与二分查找类似，即对有着单调性的答案进行二分，大多数情况下用于求解满足某种条件下的最大（小）值。、
可以求的题目：
1.求最大的最小值（NOIP2015跳石头）。
2.求最小的最大值（NOIP2010关押罪犯）。
3.求满足条件下的最小（大）值。
4.求最靠近一个值的值。
5.求最小的能满足条件的代价。

三分算法：
midl = left + (right - left)/3;
midr= right - (right - left)/3;
如果midl比midr更加靠近最值点，我们就令 right = midr- 1; 【舍弃远离的那一段】
如果midr比midl更加靠近罪之颠，令left = midl + 1； 【舍弃远离的那一段】

模板题：
题目描述
如题，给出一个 NN 次函数，保证在范围 [l, r][l,r] 内存在一点 xx，使得 [l, x][l,x] 上单调增，[x, r][x,r] 上单调减。试求出 xx 的值。
输入格式
第一行一次包含一个正整数 NN 和两个实数 l, rl,r，含义如题目描述所示。
第二行包含 N + 1N+1 个实数，从高到低依次表示该 NN 次函数各项的系数。
输出格式
输出为一行，包含一个实数，即为 xx 的值。若你的答案与标准答案的相对或绝对误差不超过 10^{-5}10 −5则算正确。
输入 #1复制
3 -0.9981 0.5
1 -3 -3 1
输出 #1复制
-0.41421
AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 1000010;
double a[15], l, r;
int n;
double check(double x) (撰写函数)
{
    double t = 1, ans = 0;
    for (int i = n; i >= 0; i--)
    {
        ans = ans + t * a[i];
        t = x * t;
    }
    return ans;
}
int main()
{
    cin >> n >> l >> r;
    for (int i = 0; i <= n; i++)
        cin >> a[i];
    double rmid, lmid;
    while (fabs(r - l) > 1e-7) (三分模板，这题是浮点数的三分，不是浮点数的话r = rmid - 1,l = lmid + 1)
    {
        rmid = r - (r - l) / 3.0;
        lmid = l + (r - l) / 3.0;
        if (check(lmid) > check(rmid))
            r = rmid;
        else
            l = lmid;
    }
    printf("%.5lf\n", l);
}

dfs(深度优先搜索)和bfs(广度优先搜索)算法(BFS就是队列，DFS就是一个栈，也可以想象成一个倒立的树)
(1)DFS(深度优先搜索):(记得要有回溯的思想！！！！DFS最重要的就是回溯，也就是要把visited[i]重置为0，DFS适用于带有很强目的性的查找和搜索问题)
DFS是图论里面的一种搜索算法，他可以由一个根节点出发，遍历所有的子节点，进而把图中所有的可以构成树的集合都搜索一遍，达到全局搜索的目的。
所以很多问题都可以用dfs来遍历每一种情况，从而得出最优解(求最优解不一定是动规或者贪心)，但由于时间复杂度太高，我们也叫做暴力搜索。根据dfs
的英文全写，我们可以知道这是一种深度优先搜索的搜索算法，什么叫做深度优先？意思就是它搜索一颗子树时，它要遍历到底才会 “回头” 而且我们可以
看到如果 你面对的图是一个 无向图，这个时候这个树将会持续搜索因为可能会形成环路，使得栈的结构一直进进出出，导致程序崩溃，所以我们也因该注意
，在写DFS时，如果面对的是一个无向图的话我们需要进行标记。
一般的标记方法有:
①这个点的父节点被标记，使得子节点不能回到父节点造成循环
②访问过的节点被标记
对于暴搜来说，因其复杂度太高，就会想去优化它的复杂度，这一过程称为剪枝，剪纸分为可行性剪枝和最优化剪枝，关于剪枝引申出一种名为记忆化搜索的
方法，该方法与动态规划类似。
DFS多用于连通性问题因为其运行思路与人脑思维很像。
伪代码:
void DFS(Vertex v)(类似于树的先序遍历)
{visit[v]=true;(visit为每个节点定义的变量)
for(v的每个邻接点w)
if(!visit[w])
DFS(w);
}
例题:
在一个给定形状的棋盘(形状可能是不规则的)上面摆放棋子，棋子没有区别.要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求
解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C.
input:
输入含有多组测试数据.
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目.N<=8，k<=n
当为-1-1时表示输入结束.
随后的n行描述了棋盘的形状:每行有n个字符，其中#表示棋盘区域.表示空白区域(数据保证不出现多余的空白行或者空白列)。
output
对于每一组数据，给出一行输出，输出摆放的方案数目C(数据保证C<2^31)。
sample input:
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
sample output:
2
1
AC代码:
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int b[9]; 
char a[9][9];
int num;
int n,m,k;
void dfs(int x){
	if(m==k){
	num++;
	return;
}
	if(x>=n)
	return;
	for(int j=0;j<n;j++){
			if(a[x][j]=='#'&&b[j]==0){
				b[j]=1;
				m++;
				dfs(x+1);
				b[j]=0;
				m--;
			}
		}
		dfs(x+1);
	}
int main(){
	while(cin>>n>>k){
		if(n==-1&&k==-1)
		break;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
			cin>>a[i][j];	
			}
		}
		m=num=0;
		dfs(0);
		cout<<num<<endl;
	}
}
剪枝：提前判断这条路走下去合不合法，不合法有冲突直接回溯不继续往下走。
剪枝：
1.优化搜索顺序
2.
n皇后问题AC代码(包含剪枝)：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <deque>
using namespace std;
const int N = 20;
char a[N][N];
int n;
bool dg[N], udg[N], col[N]; (dg是正对角线线上有没有棋子，udg是反对角线有没有棋子，col是一列里面有没有棋子)
void dfs(int u) (逐行判断)
{
  if (u == n)
  {
    for (int i = 0; i < n; i++)
    {
      for (int j = 0; j < n; j++)
          cout << a[i][j];
      cout << endl;
    }
    cout << endl;
    return;
  }
  for (int i = 0; i < n; i++)
  {
    if (!dg[i + u] && !udg[i - u + n] && !col[i]) (这个dg和udg的公式可以用斜率为1的直线判断)
    {
      a[u][i] = 'Q';
      dg[i + u] = udg[i - u + n] = col[i] = true;
      dfs(u + 1);
      dg[i + u] = udg[i - u + n] = col[i] = false;
      a[u][i] = '.';
    }
  }
}
int main()
{
  cin >> n;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      a[i][j] = '.';
  dfs(0);
}

(2)BFS(广度优先搜索，相当于树的层序遍历)(注意每种状态或者情况在BFS函数中都要考虑和标记走过的点)
只有在边的权重都是1的时候才能用bfs求最短路问题。
与DFS相对的那就是BFS了，BFS称为宽度优先搜索也叫做广度优先搜索，他是按层遍历每一种状态的下一种状态。BFS因为是按照一层一层访问，所以适合
有目标求最短步数或者时间。(题目出现最短，最少可以优先考虑)
例题：
你被困在一个3D地牢，需要找到最快的出路！地牢由单位立方体组成，这些立方体可以填充岩石，也可以不填充岩石。向北、南、东、西、上或下移动一个
单位需要一分钟。你不能对角移动，迷宫四周都是坚硬的岩石。
逃跑是可能的吗？如果是，需要多长时间？
input:
输入由若干地牢组成。每个地牢描述从包含三个整数L、R和C的一行开始(都限制在30个大小)。
我是组成地牢的等级数。
R和C是构成每个级别计划的行数和列数。
然后将跟随L个R行块，每一行都包含C字符。每个字符描述地牢的一个单元格。充满岩石的单元格由“#”表示，空单元格由“.”表示。你的起始位置用“S”表示，出口用字母“E”表示。在每个级别之后有一个空行。对于L、R和C，输入由三个零终止。
输出量
每个迷宫产生一行输出。如果可能到达出口，请打印表单的一行。
在x分钟内逃走了。
其中x被最短的逃逸时间所代替。
如果无法转义，请打印行
被困住了！
sample input
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
sample output:
Escaped in 11 minute(s).
Trapped!

AC代码：
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int l,r,c,sx,sy,sz,ex,ey,ez,x,y,z;
int visited[35][35][35];
char m[35][35][35]; 
class dir{
	public:
	int x,y,z;
} ;
int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,-1,1,0,0};
int dz[6]={0,0,0,0,1,-1};
int bfs(){
	memset(visited,-1,sizeof(visited));
	queue<dir> q;
	dir d;
	d.x=sx;
	d.y=sy;
	d.z=sz;
	q.push(d);
	visited[sx][sy][sz]=0;
	while(q.size()){
		dir t=q.front();
		q.pop();
		for(int i=0;i<6;i++){
			x=t.x+dx[i];
			y=t.y+dy[i];
			z=t.z+dz[i];
			if(x>=0&&x<l&&y>=0&&y<r&&z>=0&&z<c&&visited[x][y][z]==-1&&m[x][y][z]=='.'){
				visited[x][y][z]=visited[t.x][t.y][t.z]+1;
				dir a;
				a.x=x;
				a.y=y;
				a.z=z;
				q.push(a); 
			}
		}
	}
	return visited[ex][ey][ez];
}
int main()
{
while(cin>>l>>r>>c&&l&&r&&c){
for(int i=0;i<l;i++){
	for(int j=0;j<r;j++){
		for(int k=0;k<c;k++){
			cin>>m[i][j][k];
			if(m[i][j][k]=='S'){
			sx=i;
			sy=j;
			sz=k;
		}
            else if(m[i][j][k]=='E'){
            	ex=i;
            	ey=j;
            	ez=k;
            	m[i][j][k]='.';
			}
		}
	}
}
int ans=bfs();
if(ans==-1)
cout<<"Trapped!"<<endl;
else
	cout<<"Escaped in "<<ans<<" minute(s)."<<endl;
}
}


并查集：(也是一种优化算法)
1.将两个集合合并。
2.判断两个元素是否在一个集合。
3.判断图是否有环，或者说判断树的最近父节点之类的问题。
基本原理:每个集合用一棵树来表示，树根的编号就是集合的编号，每个节点存储他的父节点，p[x]表示x的父节点。
1.如何判断父节点？(p[x] ==x，即代表这个节点就是根节点)
2.如何求x的集合编号(找根节点)?  while(p[x] != x) x = p[x];
时间复杂度基本都在第二步这个地方，所以需要我们对于这个步骤进行优化，p[x] = find(x);(代表只要遍历一次x的祖先之后，就把这条路上
所有的节点都直接指向根节点，这个方法的名字叫做路径压缩)
3.如何合并两个集合？ 假设p[x]是x的根节点，p[y]是y的根节点，p[x] = y;
注意要定义一个记录父节点的数组！！！
模板:
一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
现在要进行 m 个操作，操作共有两种：
M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中；
输入格式
第一行输入整数 n 和 m
接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。
输出格式
对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤n,m≤105
输入样例：
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
输出样例：
Yes
No
Yes
AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int fa[N], n, m;

int find(int x) (找到根节点)
{
  if (x != fa[x])
    fa[x] = find(fa[x]); (路径压缩)
  return fa[x];
}
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++) (初始化，每个节点的根节点都是自己)
    fa[i] = i;
  while (m--)
  {
    char op;
    int a, b;
    cin >> op >> a >> b;
    if (op == 'M')
    {
      fa[find(a)] = find(b);
    }
    else
    {
      if (find(a) == find(b))
        cout << "Yes" << endl;
      else
        cout << "No" << endl;
    }
  }
}
模板题2:
给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。
现在要进行 m 个操作，操作共有三种：
C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
Q2 a，询问点 a 所在连通块中点的数量；
输入格式
第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。
输出格式
对于每个询问指令 Q1 a b，如果 a 和 b 在同一个连通块中，则输出 Yes，否则输出 No。
对于每个询问指令 Q2 a，输出一个整数表示点 a 所在连通块中点的数量
每个结果占一行。
数据范围
1≤n,m≤105
输入样例：
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
输出样例：
Yes
2
3
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int fa[N], n, m, size[N]; (size[]就是记录根节点有几个子节点的数组，注意size是针对根节点计算的)

int find(int x)
{
  if (x != fa[x])
    fa[x] = find(fa[x]);
  return fa[x];
}
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
  {
    fa[i] = i;
    size[i] = 1; 
  }
  while (m--)
  {
    string op;
    int a, b;
    cin >> op;
    if (op == "C")
    {
      cin >> a >> b;
      if (find(a) == find(b)) 
        continue;
      else
      {
        size[find(b)] += size[find(a)]; (这步和下面那步顺寻不能颠倒，如果a和b的根节点不一样，要先把a和b的size给b(因为size针对的是根节点所以给b)
        fa[find(a)] = find(b);             然后再把b给a的父亲节点)
      }
    }
    else if (op == "Q1")
    {
      cin >> a >> b;
      if (find(a) == find(b))
        cout << "Yes" << endl;
      else
        cout << "No" << endl;
    }
    else if (op == "Q2")
    {
      cin >> a;
      cout << size[find(a)] << endl;
    }
  }
}

1.find_root()找到x根节点。
2.union(x,y)合并x和y。
题目：
roblem Description
上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道
都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，
小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比
如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 

Input
输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据
之间有一个空行。 整个文件以两个-1结尾。
 
Output
对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出"Yes"，否则输出"No"。
 
Sample Input
6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0

-1 -1
Sample Output
  
Yes
Yes
No

AC代码:

#include<iostream>
#include<cstdio>
#include<cstring>
const int MAX=100001;
int father[MAX];
int mark[MAX];
int n;
using namespace std;
void init()//初始化
{
    int i;
    for(i=1;i<=MAX;++i)
    father[i]=i,mark[i]=0;
}
int find_father(int x)
{
    while(x!=father[x])
    {
        x=father[x];
    }
    return x;
}
void join_tree(int x,int y)
{
    mark[x]=1;//只要加进来的都标记
    mark[y]=1;
    int a,b;
    a=find_father(x);
    b=find_father(y);
    if(a!=b)
    father[a]=b;
}
int main()
{
    int i,x,y,flag,sum;
    while(cin>>x>>y&&(x!=-1&&y!=-1))
    {
        init();
        memset(mark,0,sizeof(mark));
        if(find_father(x)==find_father(y))
        {
            if(x==0&&y==0)//特殊测试数据，0 0是符合的所以输出Yes
            cout<<"Yes"<<endl;
            else
            cout<<"No"<<endl;
        }
        else
        {
            flag=1;
            join_tree(x,y);//新节点加进树里面
            while(cin>>x>>y&&(x||y))
            {
                if(find_father(x)==find_father(y))//如果有环的话，就会相等，因为没环会逐渐加进树里面
                flag=0;
                else
                join_tree(x,y);
            }
            sum=0;
            for(i=1;i<MAX;++i)
            {
                if(father[i]==i&&mark[i])//一棵树只有一个根节点，如果多了根节点那么就不是树，也不符合题意所有的通道都是连通的
                sum+=1;
            }
            if(sum>1)//根节点不是1就输出No
            flag=0;
            if(flag==1)
            cout<<"Yes"<<endl;
            else
            cout<<"No"<<endl;
        }
    }
    return 0;
}
今天是伊格内修斯的生日。他邀请了很多朋友。现在是晚餐时间。Ignatius 想知道他至少需要多少张桌子。你要注意，并不是所有的朋友都互相认识，所有的
朋友都不想和陌生人呆在一起。这个问题的一个重要规则是，如果我告诉你 A 认识 B，B 认识 C，这意味着 A、B、C 彼此认识，所以他们可以留在一张桌子
上。
例如：如果我告诉你A认识B，B认识C，D认识E，那么A、B、C可以留在一张桌子上，而D、E必须留在另一张桌子上。所以伊格内修斯至少需要 2 张桌子。
input:
输入以整数 T(1<=T<=25) 开头，表示测试用例的数量。然后是 T 测试用例。每个测试用例以两个整数 N 和 M(1<=N,M<=1000) 开始。N 表示好友的数量，好友从 1 到 N 标记，然后是 M 行。每行由两个整数 A 和 B(A!=B) 组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间会有一个空行。
output:
对于每个测试用例，只需输出 Ignatius 至少需要多少张表。不要打印任何空白。
sample input:
2
5 3
1 2
2 3
4 5

5 1
2 5
sample output
2
4
AC 代码：
#include<bits/stdc++.h>
#include <cstring>
#include <algorithm>
using namespace std;
const int  MAX=100005;
int father[MAX];
void init(){
  for(int i = 1;i <= MAX;i++ ){
    father[i]=i;
  }
}
int find_root(int x){
  while(x != father[x]){
    x = father[x];
  }
  return x;
}
void union_father(int x,int y){
  int x_root = find_root(x);
  int y_root = find_root(y);
    if(x_root!=y_root)
      father[x_root] = y_root;
}

int main(){
   int t,m,n,a,b;
   cin>>t;
   while(t--){
     int ans=0;
     cin>>n>>m;
     init();
     for(int i=1;i<=m;i++){
       cin>>a>>b;
      union_father(a,b);
       }
      for(int i=1;i<=n;i++){
        if(father[i]==i)
        ans++;
      }
      cout<<ans<<endl;
       }
     }

hash表:
作用:把一个庞大的数据映射到0-n的数。例:1e9变换到1e5
说白了要定义一个哈希函数，但是会出现有冲突的情况，所以要处理冲突，常用开放寻址法,hash函数一般都是h(x) = x mod N,代码写成k = 
(x % N + N) % N,N一定要是质数这样冲突比较小。N要设为操作次数的二到三倍。
求N的代码:
for(int i = 200000; ;i++)
{
bool flag = true;
for(int j = 2; j * j <= i; j++)
{
if(i%j == 0)
{
flag = false;
break;
}
}
}
一.存储结构
1.开放寻址法
2.拉链法(弄一个数组h，有冲突的数据放在数组其中一个数据延展出来的单链表)
例:
维护一个集合，支持如下几种操作：
I x，插入一个数 x；
Q x，询问数 x 是否在集合中出现过；
现在要进行 N 次操作，对于每个询问操作输出对应的结果。
输入格式
第一行包含整数 N，表示操作数量。
接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。
输出格式
对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤N≤105
−109≤x≤109
输入样例：
5
I 1
I 2
I 3
Q 2
Q 5
输出样例：
Yes
No
AC:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <math.h>
using namespace std;

const int N = 100003;
int val[N], ne[N], h[N], idx;

void insert(int x)
{
  int k = (x % N + N) % N;
  val[idx] = x;
  ne[idx] = h[k];
  h[k] = idx;
  idx++;
}
bool find(int x)
{
  int k = (x % N + N) % N;
  for (int i = h[k]; i != -1; i = ne[i])
  {
    if (x == val[i])
    {
      return true;
    }
  }
  return false;
}
int main()
{
  int n, x;
  cin >> n;
  memset(h, -1, sizeof(h));
  while (n--)
  {
    char op;
    cin >> op;
    if (op == 'Q')
    {
      cin >> x;
      if (find(x))
        cout << "Yes" << endl;
      else
        cout << "No" << endl;
    }
    else
    {
      cin >> x;
      insert(x);
    }
  }
}


二.字符串哈希方式
  


动态规划：
有限集中的最值，最优解。
动态规划解题步骤分为两个阶段：
1.状态表示(化0为整)f(i)：
一.集合，状态表示的是哪一个集合，集合一般是所有满足某某某条件的方案的集合(一般是题目给的范围限制)。
二.属性，即存储的状态表示和集合之间的关系max/min/
2.状态计算(化整为0)：
集合的划分，将大的集合f(i)划分为几个小集合，也就是化为几个子问题，子问题划分的依据一般是寻找最后一个不同点

1.背包问题
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8

dp思路:
（1）状态f[i][j]定义：前 i 个物品，背包容量 j 下的最优解（最大价值）：
当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0] = 0开始决策，有 NN 件物品，则需要 NN 次决 策，每一次对第 ii 件物品的决策，状态f[i][j]不断由之前的状态更新而来。
（2）当前背包容量不够（j < v[i]），没得选，因此前 ii 个物品最优解即为前 i−1i−1 个物品最优解：
对应代码：f[i][j] = f[i - 1][j]。
（3）当前背包容量够，可以选，因此需要决策选与不选第 ii 个物品：
选：f[i][j] = f[i - 1][j - v[i]] + w[i]。
不选：f[i][j] = f[i - 1][j] 。
我们的决策是如何取到最大价值，因此以上两种情况取 max(）
01背包：
代码实现:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N], w[N];
int main()
{
   int n, m;
   cin >> n >> m;
   for (int i = 1; i <= n; i++)
   {
      cin >> v[i] >> w[i];
   }
   for (int i = 1; i <= n; i++)
   {
      for (int j = 0; j <= m; j++)
      {
         f[i][j] = f[i - 1][j];
         if (j >= v[i])
         {
            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
         }
      }
   }
   cout << f[n][m] << endl;
}
完全背包:
#include <bits/stdc++.h> (这种写法较为朴素，很容易超时，下面有优化的写法)
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N], w[N];

int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> v[i] >> w[i];
  for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
      for (int k = 0; k * v[i] <= j; k++)
        f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
  cout << f[n][m] << endl;
}
优化完全背包:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N], w[N];

int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> v[i] >> w[i];
  for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
    {
      f[i][j] = f[i-1][j];
      if(j>=v[i])
      f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i]);
    }
  cout << f[n][m] << endl;
}
多重背包问题朴素版本:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
using namespace std;
const int N = 110;
int f[N][N];
int v[N], w[N], s[N];

int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> v[i] >> w[i] >> s[i];
  for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
      for (int k = 0; k <= s[i] && k*v[i]<=j; k++)
        f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
  cout << f[n][m] << endl;
}
二进制优化多重背包问题:
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt ++ ;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt ++ ;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
分组背包问题:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
using namespace std;
const int N = 110;
int v[N][N], w[N][N], s[N];
int f[N];
int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
  {
    cin >> s[i];
    for (int j = 0; j < s[i]; j++)
      cin >> v[i][j] >> w[i][j];
  }
  for (int i = 1; i <= n; i++)
    for (int j = m; j >= 0; j--)
      for (int k = 0; k < s[i]; k++)
        if (v[i][k] <= j)
          f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
  cout << f[m] << endl;
}
线性DP问题:
就是答案搜索的过程是线性的样子，上面那几个背包问题也是线性DP的表现。
例题1：
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
输入格式
第一行包含整数 n，表示数字三角形的层数。
接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。
输出格式
输出一个整数，表示最大的路径数字和。
数据范围
1≤n≤500,
−10000≤三角形中的整数≤10000
输入样例：
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例：
30

思路:
状态表示f[i][j]:
集合：所有从起点，走到f[i][j]的路径。
属性：集合分为两个部分，一个是从左上走过来的情况，一个是右上走过来的情况。
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <stack>
using namespace std;
const int N = 510, INF = 1e9; (这个INF是那些不存在的点的值，在初始化的时候相当于不存在的点初始化为负无穷)
int a[N][N];
int f[N][N];
int main()
{
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
      cin >> a[i][j];

  for (int i = 1; i <= n; i++)
    for (int j = 0; j <= i + 1; j++)
      f[i][j] = -INF; (所有点都先初始化为负无穷，注意j的取值范围左上和右上都要多初始化一个点)
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
      f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);

  int ans = -INF;
  for (int i = 1; i <= n; i++)
    ans = max(ans, f[n][i]); (对最后一层所有的数进行判断，确保所有路径答案是最大值，因为上面算出来的f[i][j]是当前列和上一列路径的最大值)

  cout << ans << endl;
}
例题2：最长上升子序列
给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。
输入格式
第一行包含整数 N。
第二行包含 N 个整数，表示完整序列。
输出格式
输出一个整数，表示最大长度。
数据范围
1≤N≤1000，
−109≤数列中的数≤109
输入样例：
7
3 1 2 1 8 5 6
输出样例：
4

AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <deque>
using namespace std;
const int N = 1010;
int f[N], a[N];
int main()
{
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++)
    cin >> a[i];
  int ans = 0;
  for (int i = 1; i <= n; i++)
  {
    f[i] = 1;
    for (int j = 0; j < i; j++)
    {
      if(a[i] > a[j])
      f[i] = max(f[i], f[j] + 1);
    }
  }
  for (int i = 1; i <= n; i++)
    ans = max(ans, f[i]);
  cout << ans << endl;
}

最长上升公共子序列：
题目：
找到a字符串和b字符串中最大的相同字串长度
状态表示：
集合：f[i][j] = 所有在a序列前i个字母中出现过的，且在b序列前j个字母中出现过的子序列
属性：max
状态计算：
总集合集合分为四个情况，选a选b,选a不选b，不选a选b，不选a不选b。
但是不选a不选包含在不选a选b和选a不选b的情况，所以总的来说我们只需要考虑除了不选a不选b三种情况。
AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;
typedef pair<int, int> PII;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    scanf("%s%s", a + 1, b + 1);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
             f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j])
            f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }

    cout<<f[n][m]<<endl;
}

最短编辑距离：

区间dp问题：(区间dp基本都是表示一个区间，所以状态表示一般是f[i][j]，表示i到j这个区间)
模板题：
设有 N 堆石子排成一排，其编号为 1，2，3，…，N。
每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。
每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
例如有 4 堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1，2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；
如果第二步是先合并 2，3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。
问题是：找出一种合理的方法，使总的代价最小，输出最小代价。
输入格式
第一行一个数 N 表示石子的堆数 N。
第二行 N 个数，表示每堆石子的质量(均不超过 1000)。
输出格式
输出一个整数，表示最小代价。
数据范围
1≤N≤300
输入样例：
4
1 3 5 2
输出样例：
22

状态表示：
集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式
特征：min

状态计算：
假设区间长度为k,因为总的都是左边石子和右边石子合并，所以我们将集合分为i到j分成前1和后k-1堆合并，前两堆和后k-2堆合并,,,

AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
#include <climits>
using namespace std;
typedef pair<int, int> PII;
const int N = 310;
int f[N][N];
int sum[N];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> sum[i];
    for (int i = 1; i <= n; i++)
        sum[i] += sum[i - 1]; (因为最后一次合并肯定是合并两堆石子，而且消耗的代价一定是所有石子的总和，所以我们需要求一个前缀和)
    for (int len = 2; len <= n; len++) (先枚举区间的长度)
        for (int i = 1; i + len - 1 <= n; i++) (i是区间的起点)
        {
            int l = i, r = i + len - 1;
            f[l][r] = 1e9; (一定要定义一个无穷大的数，不然后面的min一定是0)
            for (int k = l; k < i + len - 1; k++) (k就是小区间合并时两块区间合并的分界点)
                f[l][r] = min(f[l][k] + f[k + 1][r] + sum[r] - sum[l - 1], f[l][r]);
        }
    cout << f[1][n] << endl;
}

高精度:
高精度加法：
存储高位数据时，用数组存储大整数，数组要倒着存储，也就是个位数存到数组的a[0]上,注意定义一个t来处理十进制的余数。
模板:
题目：计算两个大整数的加法。
AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

vector<int> add(vector<int> &A, vector<int> &B)
{
  int t = 0;
  vector<int> C;
  for (int i = 0; i < A.size() || i < B.size(); i++) (for的判断条件一定要这么写，不然有可能在计算1+999999时会出现10这种你结果)
  {
    if (A.size() > i)
      t += A[i];
    if (B.size() > i)
      t += B[i];
    C.push_back(t % 10);
    t = t / 10;
  }
  if (t)
    C.push_back(1);
  return C;
}

int main()
{
  string a, b;
  vector<int> A, B;
  cin >> a >> b;
  for (int i = a.size() - 1; i >= 0; i--)
    A.push_back(a[i] - '0');
  for (int i = b.size() - 1; i >= 0; i--)
    B.push_back(b[i] - '0');

  vector<int> c = add(A, B);

  for (int i = c.size() - 1; i >= 0; i--)
    cout << c[i];
}
高精度减法:
存储高位数据时，用数组存储大整数，数组要倒着存储，也就是个位数存到数组的a[0]上,减法有两种情况，一种是a[i]-b[i]-t>0(t是上一位借一位的结果)就
直接减就可以了，若a[i]-b[i]-t<0，就要往前借一位，变成a[i]-b[i]+10-t.还要注意的是要设置一个cmp函数，作用是比较两个大整数哪个比较大，如果相同
位数一样长的话还得比较哪个大整数比较大。
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;
bool cmp(vector<int> &m, vector<int> &n) (判断大整数A长还是大整数B长)
  if (m.size() != n.size())
    return m.size() > n.size();
  else
  {
    for (int i = m.size() - 1; i >= 0; i--)
      if (m[i] != n[i])
        return m[i] > n[i];
    return true;
  }
}
vector<int> sub(vector<int> &m, vector<int> &n)
{
  int t = 0;
  vector<int> c;
  for (int i = 0; i < m.size(); i++)
  {
    t = m[i] - t;
    if (i < n.size())
      t = t - n[i];
    c.push_back((t + 10) % 10); (这个表达式表示不管t是负数还是正数都可以通过这个表达式表示)
    if (t < 0)
      t = 1;
    else
      t = 0;
  }
  while (c.size() > 1 && c.back() == 0) (要有这个去除前导0的操作，不然12412-12411=00001而不是1)
    c.pop_back();
  return c;
}
int main()
{
  string a, b;
  vector<int> m, n, c;
  cin >> a >> b;
  for (int i = a.size() - 1; i >= 0; i--)
    m.push_back(a[i] - '0');
  for (int i = b.size() - 1; i >= 0; i--)
    n.push_back(b[i] - '0');

  if (cmp(m, n))
  {
    vector<int> c = sub(m, n);
    for (int i = c.size() - 1; i >= 0; i--)
      cout << c[i];
  }
  else
  {
    cout << '-';
    vector<int> c = sub(n, m);
    for (int i = c.size() - 1; i >= 0; i--)
      cout << c[i];
  }
}
高精度乘法:
一般是一个大整数乘以一个小整数，大整数一律用字符串输入后用数组倒序存储。小整数就用int类型存储就可以了。
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

vector<int> mul(vector<int> &A, int b)
{
  int t = 0;
  vector<int> c;
  for (int i = 0; i < A.size() || t; i++) (i<A.size() || t的意思是在A的size()meiyou处理完或者说进位t没有处理完的情况下循环不停止，假如没有这个||t的话，
例如3284925390x19出来的结果就是2413582410而不是正确答案62413582410)
  {
    if (i < A.size())（要讨论下是A没弄完的情况还是进位没有处理完的情况，若是A没处理完就要执行下面的语句）
      t += A[i] * b;
    c.push_back(t % 10);
    t = t / 10;
  }
   while (c.size() > 1 && c.back() == 0) (要有这个去除前导0的操作，不然12412x0=00000而不是0)
    c.pop_back();
  return c;
}

int main()
{
  string a;
  int b;
  cin >> a >> b;
  vector<int> A;
  for (int i = a.size() - 1; i >= 0; i--)
    A.push_back(a[i] - '0');

  vector<int> c = mul(A, b);

  for (int i = c.size() - 1; i >= 0; i--)
    cout << c[i];
}
高精度除法:
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

vector<int> div(vector<int> &A, int b, int &r) （记住r一定要带上&，因为最后只返回了c，但没有返回r，加上&r之后在函数内r的改变会影响主函数的r）
{
  r = 0;
  vector<int> c;
  for (int i = A.size() - 1; i >= 0; i--) (记住这个顺寻是从后向前，因为除法运算中先从高位开始算，但是我们大整数存储都是倒序，故计算时要再倒一次)
  {
    r = r * 10 + A[i];
    c.push_back(r / b);
    r = r % b;
  }
  reverse(c.begin(),c.end()); (记得要将c倒转之后再返回，因为数组c我们通过上面的运算把他。。。反正除法所有的循环都是逆序，这里要reverse就对了)
  while (c.size() > 1 && c.back() == 0)
    c.pop_back();
  return c;
}

int main()
{
  string a;
  int b;
  cin >> a >> b;
  vector<int> A;
  for (int i = a.size() - 1; i >= 0; i--)
    A.push_back(a[i] - '0');

  int r;

  vector<int> c = div(A, b, r); (因为除法要多算一个余数，要多带一个r进去)

  for (int i = c.size() - 1; i >= 0; i--)
    cout << c[i];
  cout << endl;
  cout << r;
}

双指针算法:
核心思想:如果暴力写两重循环的话，时间复杂度是O(n^2),用双指针的话就是优化到O(n).
模板:
for(i = 0, j = 0; i < n; i ++){
   while(j < i && check(i,j))
       j++;
    
   //每道题目的具体逻辑
}
例题:
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

输入格式
第一行包含整数 n。

第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。

输出格式
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

数据范围
1≤n≤105
输入样例：
5
1 2 2 3 5
输出样例：
3
AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;
int s[N], a[N];

int main()
{
  int n, ans = 0;
  cin >> n;
  for (int i = 0; i < n; i++)
    cin >> a[i];

  for (int i = 0, j = 0; i < n; i++)
  {
    s[a[i]]++;
    while (s[a[i]] > 1)
    {
      s[a[j]]--;
      j++;
    }
    ans = max(ans, i - j + 1);
  }
  cout << ans << endl;
}
位运算:
记住，数字在计算机中的存储方式都是原码，所以位运算没有将数字换位二进制这一个多余的操作。
1.与：&  2.或：|   3.取反：~   4.异或：^  0^0==0,1^1==0(一样的就为0，不一样就是1)      5.右移：a>>k 从右边开始向前减去k个数      
6.左移：a<<k = 向右边加k个0
两种题目:
一.求一个整数n的二进制表示里面第k位是几。
1.先把第k位移到最后一位。
2.看一下个位是几
总结:公式就是n >> k&1;
二.lowbit(x)返回x的最后一位1。例如:101000返回1000.
模板:
int lowbit(int x){
   return x&(-x);
}
例题:
给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。

输入格式
第一行包含整数 n。

第二行包含 n 个整数，表示整个数列。

输出格式
共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。

数据范围
1≤n≤100000,
0≤数列中元素的值≤109
输入样例：
5
1 2 3 4 5
输出样例：
1 1 2 1 2

AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

int lowbit(int x)
{
  return x & -x;
}

int main()
{
  int n, x;
  cin >> n;
  while (n--)
  {
    int ans = 0;
    cin >> x;
    while (x)
    {
      x -= lowbit(x); (每次减去x的最后一位1)
      ans++;
    }
    cout << ans << ' ';
  }
}

离散化算法:
此算法适用于整数范围很大，但是实际数据不多的
例如a[i] = 1 2 3 5 10000000000000000 但是我们不能开10000000000000000这么大的数组，所以用离散化更换其下标。
1.去重
2.如何找出x离散化之后的值 (二分)

题目:
假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。

接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。

输入格式
第一行包含两个整数 n 和 m。

接下来 n 行，每行包含两个整数 x 和 c。

再接下来 m 行，每行包含两个整数 l 和 r。

输出格式
共 m 行，每行输出一个询问中所求的区间内数字和。

数据范围
−109≤x≤109,
1≤n,m≤105,
−109≤l≤r≤109,
−10000≤c≤10000
输入样例：
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例：
8
0
5
AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 300010;

typedef pair<int, int> PII;

vector<PII> add, deal; (定义的这个vector容器的类型是pair)

int a[N], s[N]; (a是离散化后的数组，s是离散后数组的前缀和)

vector<int> alls;

int find(int x) (用二分查找查找已经离散化后的数组的某个值)
{
  int l = 0, r = alls.size() - 1, mid;
  while (l < r)
  {
    mid = (l + r) / 2;
    if (alls[mid] >= x)
      r = mid;
    else
      l = mid + 1;
  }
  return r + 1;
}

int main()
{
  int n, m;
  cin >> n >> m;
  for (int i = 0; i < n; i++) (要在pair里面加一次也要在vector里面加一次)
  {
    int x, c;
    cin >> x >> c;
    add.push_back({x, c});
    alls.push_back(x);
  }
  for (int i = 0; i < m; i++)
  {
    int l, r;
    cin >> l >> r;
    deal.push_back({l, r});
    alls.push_back(l);
    alls.push_back(r);
  }

 //离散化的去重步骤就是下面两行，去重后则完成离散化
  sort(alls.begin(), alls.end());
  alls.erase(unique(alls.begin(), alls.end()), alls.end());

  for (auto item : add) (遍历add)
  {
    int x = find(item.first);
    a[x] += item.second;
  }
  for (int i = 1; i <= alls.size(); i++)
    s[i] = s[i - 1] + a[i];
  for (auto item : deal)
  {
    int l = find(item.first); (找到离散化后的l和r对应的值)
    int r = find(item.second);
    cout << s[r] - s[l-1] << endl;
  }
}
区间合并算法:



数组实现链表:
要定义几个值:
head 表示头结点的下标，(头节点指向的下一元素，即头节点的指针域)
val[i] 表示节点i的值
ne[i] 表示节点i的next指针是多少(不知道为什么定义next会报错，可能有什么next的库函数之类的)
idx 存储当前已经用到了哪个点 (就是某个点的索引，下标，一般来说添加数据时next[]都指向idx也就是要加入点的下标)

例题:
实现一个单链表，链表初始为空，支持三种操作：

向链表头插入一个数；
删除第 k 个插入的数后面的数；
在第 k 个插入的数后插入一个数。
现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

输入格式
第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

H x，表示向链表头插入一个数 x。
D k，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
I k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。
输出格式
共一行，将整个链表从头到尾输出。

数据范围
1≤M≤100000
所有操作保证合法。

输入样例：
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
输出样例：
6 4 6 5

AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int ne[N], val[N], idx, head;

void init()
{
  head = -1;
  idx = 0;
}

void add_to_head(int x)
{
  val[idx] = x;
  ne[idx] = head;
  head = idx;
  idx++;
}

void remove(int k)
{
  ne[k] = ne[ne[k]];
}

void add(int k, int x)
{
  val[idx] = x;
  ne[idx] = ne[k];
  ne[k] = idx;
  idx++;
}

int main()
{
  int m;
  cin >> m;
  init();
  while (m--)
  {
    int k, x;
    char a;
    cin >> a;
    if (a == 'D')
    {
      cin >> k;
      if (!k)
        head = ne[head];
      remove(k - 1); (k-1是因为0号元素是第一个插入的点)
    }
    else if (a == 'H')
    {
      cin >> x;
      add_to_head(x);
    }
    else
    {
      cin >> k >> x;
      add(k - 1, x); (k-1是因为0号元素是第一个插入的点)
    }
  }
  for (int i = head; i != -1; i = ne[i])
      cout << val[i] << ' ';
    cout << endl;
}

双向链表:
和单链表差不多，差别是双向链表一个节点不止有指向后面的指针，还能指向前面。
所以有三个数组要定义l[N](左边指向的点)r[N](右边指向的点)val[N](当前点的值)。
0表示左端点,1表示右端点。
例题:
实现一个双链表，双链表初始为空，支持 5 种操作：

在最左侧插入一个数；
在最右侧插入一个数；
将第 k 个插入的数删除；
在第 k 个插入的数左侧插入一个数；
在第 k 个插入的数右侧插入一个数
现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

输入格式
第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

L x，表示在链表的最左端插入数 x。
R x，表示在链表的最右端插入数 x。
D k，表示将第 k 个插入的数删除。
IL k x，表示在第 k 个插入的数左侧插入一个数。
IR k x，表示在第 k 个插入的数右侧插入一个数。
输出格式
共一行，将整个链表从左到右输出。

数据范围
1≤M≤100000
所有操作保证合法。

输入样例：
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
输出样例：
8 7 7 3 2 9

AC代码:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int l[N], r[N], val[N], idx;

void init()
{
  l[1] = 0;
  r[0] = 1;
  idx = 2;
}

void remove(int k)
{
  l[r[k]] = l[k];
  r[l[k]] = r[k];
}

void add(int k, int x)
{
  val[idx] = x;
  r[idx] = r[k];
  l[idx] = k;
  l[r[k]] = idx;
  r[k] = idx;
  idx++;
}

int main()
{
  int m, k, x;
  cin >> m;
  init();
  while (m--)
  {
    string a;
    cin >> a;
    if (a == "D")
    {
      cin >> k;
      remove(k + 1);  (这里以及下面的k+1是因为idx从2开始，但是题目给的k都是从1开始算的，所以我们每次写有关于k的表达式中k都要写成k+1)
    }
    else if (a == "L")
    {
      cin >> x;
      add(0, x);
    }
    else if (a == "R")
    {
      cin >> x;
      add(l[1], x);
    }
    else if (a == "IR")
    {
      cin >> k >> x;
      add(k + 1, x);
    }
    else
    {
      cin >> k >> x;
      add(l[k + 1], x);
    }
  }
  for (int i = r[0]; i != 1; i = r[i])
    cout << val[i] << ' ';
  cout << endl;
}
模拟栈:
实现一个栈，栈初始为空，支持四种操作：

push x – 向栈顶插入一个数 x；
pop – 从栈顶弹出一个数；
empty – 判断栈是否为空；
query – 查询栈顶元素。
现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

输入格式
第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。

输出格式
对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。

其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。

数据范围
1≤M≤100000,
1≤x≤109
所有操作保证合法。

输入样例：
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
输出样例：
5
5
YES
4
NO

AC:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int stk[N], tt;

void add(int x)
{
  tt++;
  stk[tt] = x;
}

int main()
{
  int m, x;
  cin >> m;
  while (m--)
  {
    string a;
    cin >> a;
    if (a == "push")
    {
      cin >> x;
      add(x);
    }
    else if (a == "pop")
    {
      tt--;
    }
    else if (a == "empty")
    {
      if (!tt)
        cout << "YES" << endl;
      else
        cout << "NO" << endl;
    }
    else if (a == "query")
    {
      cout <<  stk[tt] << endl;
    }
  }
}
单调栈:
单调递增栈模板(问右边第一个比他大)：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <math.h>
#include <queue>
using namespace std;
stack<int> stk;
const int N = 3000010;
int n, a[N], b[N];
int main()
{
  scanf("%d", &n);
  for (int i = 1; i <= n; i++)
  {
    scanf("%d", &a[i]);
    if (stk.empty())
      stk.push(i);
    else
    {
      while (stk.size() && a[i] >= a[stk.top()])
      {
        b[stk.top()] = i; 
        stk.pop();
      }
      stk.push(i);
    }
  }
  for (int i = 1; i <= n; i++)
    printf("%d ", b[i]);
}
单调递增栈模板(问左边第一个比他小):
#include <iostream>

using namespace std;

const int N = 100010;

int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;
        if (!tt) printf("-1 ");
        else printf("%d ", stk[tt]);
        stk[ ++ tt] = x;
    }
}
STL实现单调栈:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <math.h>
#include <stack>
using namespace std;
const int N = 100010;
int n;
int a[N];
int main()
{
    stack<int> stk;
    cin >> n;
    while (n--)
    {
        int x;
        cin >> x;
        while(stk.size() && x >= stk.top())
            stk.pop();
        if (stk.size())
            cout << stk.top() << ' ';
        else
            cout << "-1" << ' ';
        stk.push(x);
    }
}
模拟队列:
和上面的题目差不多意思:
AC:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int que[N], s = -1, e;

void add(int x)
{
  s++;
  que[s] = x;
}

int main()
{
  int m, x;
  cin >> m;
  while (m--)
  {
    string a;
    cin >> a;
    if (a == "push")
    {
      cin >> x;
      add(x);
    }
    else if (a == "pop")
    {
      e++;
    }
    else if (a == "empty")
    {
      if(s < e)
      cout << "YES" << endl;
      else
      cout << "NO" <<endl; 
    }
    else if (a == "query")
    {
      cout << que[e] <<endl;
    }
  }
}
单调队列(滑动窗口):
模板:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <math.h>
#include <queue>
using namespace std;
const int N = 1000010;

int a[N], q[N];

int main()
{
  int n, k;
  cin >> n >> k;
  for (int i = 0; i < n; i++)
  {
    cin >> a[i];
  }
  int tt = -1, hh = 0; (tt为队尾，hh为队头)
  for (int i = 0; i < n; i++) （这里面的i永远是队尾的下一个元素的下标）
  {
    if (hh <= tt && i - k + 1 > q[hh])
      hh++;
    while (hh <= tt && a[q[tt]] >= a[i])
      tt--;
    q[++tt] = i;
    if (i >= k - 1)
      cout << a[q[hh]] << ' '; (一定是要输出队头，因为tt--不可能把更小的数减掉，所以队头的元素一定是最小的)
  }
  cout << endl;
  tt = -1, hh = 0;
  for (int i = 0; i < n; i++)
  {
    if (hh <= tt && i - k + 1 > q[hh])
      hh++;
    while (hh <= tt && a[q[tt]] <= a[i])
      tt--;
    q[++tt] = i;
    if (i >= k - 1)
      cout << a[q[hh]] << ' ';
  }
}
kmp: (字符串查找算法)
1.先想想暴力怎么做。
2.想想怎么优化。
题目:寻找s字符数组内p的字符串
AC:
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1; (下表从1开始比较好做)

    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }

    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];  (题目是找到对应中所有的字符串，可能有多个，所以找到一个要继续找下一个)
        }
    }
}
字典树:
快速存储字符串的数据结构。
模板:
维护一个字符串集合，支持两种操作：

I x 向集合中插入一个字符串 x；
Q x 询问一个字符串在集合中出现了多少次。
共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。

输入格式
第一行包含整数 N，表示操作数。

接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。

输出格式
对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。

每个结果占一行。

数据范围
1≤N≤2∗104
输入样例：
5
I abc
Q abc
Q ab
I ab
Q ab
输出样例：
1
0
1
AC:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int son[N][26], idx, cnt[N], n; (idx是当时用到节点的索引，idx为0的意思为空节点或者说没有此节点，cnt是记录以这个节点为结尾单词的字符
串个数，son数组是son[i]此节点的子节点)

char str[N];

void insert(char str[])
{
  int p = 0; (这个设置p的意思是每次都要从根节点开始遍历)
  for (int i = 0; str[i]; i++) (str[i]是因为字符串的结尾是'/0'，所以说结束条件为str[i]就可以保证循环到最后一个字符)
  {
    int u = str[i] - 'a';
    if (!son[p][u])
      son[p][u] = ++idx;
    p = son[p][u];
  }
  cnt[p]++;
}

int query(char *str)
{
  int p = 0;
  for (int i = 0; str[i]; i++)
  {
    int u = str[i] - 'a';
    if (!son[p][u])
      return 0;
    p = son[p][u];
  }
  return cnt[p];
}

int main()
{
  cin >> n;
  while (n--)
  {
    char op;
    cin >> op >> str;
    if (op == 'I')
      insert(str);
    else
      cout << query(str) <<endl;
  }
}
数据结构堆(完全二叉树): (nlogn)
1.插入一个数
2.求集合中的最小值
3.删除最小值
4.删除任意一个元素
5.修改任意一个元素
堆是一个完全二叉树，且根节点的值小于等于左右子树。
存储方式是用一维数组存储出一个树，节点x的值为a[x]，x的左子树就是2x，右子树就是2x+1
主要有两个操作:
1.down(x):往下调整    x
2.up(x):往上调整x
堆排序模板:
输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。
输入格式
第一行包含整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
输出格式
共一行，包含 m 个整数，表示整数数列中前 m 小的数。
数据范围
1≤m≤n≤105，
1≤数列中元素≤109
输入样例：
5 3
4 5 1 3 2
输出样例：
1 2 3
AC:
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

const int N = 100010;

int n, m, a[N], e;

void down(int u)
{
  int t = u;
  if (u * 2 <= e && a[t] > a[u * 2]) （判断左子树是不是符合堆的定义）
    t = u * 2;
  if (u * 2 + 1 <= e && a[t] > a[u * 2 + 1])
    t = u * 2 + 1;
  if (t != u)
  {
    swap(a[t], a[u]);
    down(t);
  }
}
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> a[i];
  e = n;
  for (int i = n / 2; i; i--)
    down(i);
  while (m--)
  {
    cout << a[1] << ' ';
    a[1] = a[e];
    e--;
    down(1); (一定要down(1)，因为down函数传入的参数是要操作的下标)
  }
}

树的重心：(树和图要用邻接表或者邻接矩阵存，大部分是邻接表)
树的重心的定义：树的重心定义为树的某个节点，当去掉该节点后，树的各个连通分量中，节点数最多的连通分量其节点数达到最小值。树可能存在多个重心。
题目：
给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。
请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。
重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。
输入格式
第一行包含整数 n，表示树的结点数。
接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。
输出格式
输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。
数据范围
1≤n≤105
输入样例
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
输出样例：
4
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 100010,M = N*2;
int e[M],h[N],ne[M],idx;
int n;
bool st[N];
int ans = N; //最小的最大值
void add(int a,int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
int dfs(int u) //以u为根的子树中点的数量
{
    st[u] = true;
    int sum = 1,num = 0; //nun是存每一个连通块的点数的最大值
    for(int i = h[u];i!=-1;i = ne[i]){
        int j = e[i];
        if(!st[j])
        {
            int k = dfs(j);
            sum+=k;
            num = max(k,num);
        }
    }
    num = max(n-sum,num); //拿当前子树的连通块点数的最大值和除了当前连通块以外另一个连通块的最大点数
    ans = min(num,ans);
    return sum;
}
int main()
{
    cin>>n;
    memset(h,-1,sizeof(h));
    for(int i = 0; i < n - 1; i++)
    {
        int a,b;
        cin>>a>>b;
        add(a,b),add(b,a);
    }
    dfs(1);
    cout<<ans<<endl;
}
树与图的广度优先遍历：
题目：
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。
所有边的长度都是 1，点的编号为 1∼n。
请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1。
输入格式
第一行包含两个整数 n 和 m。
接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 1 的边。
输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。
数据范围
1≤n,m≤105
输入样例：
4 5
1 2
2 3
3 4
1 3
1 4
输出样例：
1
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 100010, M = N * 2;
int val[M], ne[M], h[N], idx;
int n,m;
int visited[N];
void add(int a, int b)
{
  val[idx] = b;
  ne[idx] = h[a];
  h[a] = idx;
  idx++;
}

int bfs()
{
  queue<int> q;
  memset(visited, -1, sizeof(visited));
  q.push(1);
  visited[1] = 0;
  while (!q.empty())
  {
    int t = q.front();
    q.pop();
    for (int i = h[t]; i != -1; i = ne[i])
    {
      int j = val[i];
      if (visited[j] == -1)
      {
        visited[j] = visited[t] + 1;
        q.push(j);
      }
    }
  }
  return visited[n];
}

int main()
{
  cin >> n>> m;
  memset(h, -1, sizeof(h));
  for (int i = 0; i < m; i++)
  {
    int a, b;
    cin >> a >> b;
    add(a, b);
  }

  cout << bfs() << endl;
}
拓扑序列：(这个排序是对节点进行排序与，在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。)
拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点u uu 到顶点v vv的每个有向边u v uvuv， u uu 在序列中都在v vv之前。
有向图才会有拓扑序列

step1：把所有入度为0的点入队；(入度为0的点代表这个点一定指向后面所有的点而不会被任何点指向，所以符合topu的要求)
step2：拿出队头，t = 队头
step3：枚举t的所有出边t->j，删掉t->j，因为当前考虑的t已经一定在j之前了，所以t一定符合拓扑序列的限制，所以可以先把t->j删掉。
step4：把j加到队列里去
队列里的存储顺序就是我们的拓扑序列。

这是数组模拟队列的做法，后面有个STL队列的做法，对于我来说更好理解
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 100010;
int h[N], e[N], ne[N], idx, d[N], q[N]; (d数组是存储每个点的入度情况)
int n, m;
void add(int a, int b) (邻接表的存储)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topo()
{
    int tt = -1, hh = 0;
    for (int i = 1; i <= n; i++) (第一步先把入度为0的点先加到队列里面)
        if (!d[i])
            q[++tt] = i;
    while (tt >= hh)
    {
        int t = q[hh];
        hh++;
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            d[j]--; (这个是队头指向的节点，该节点的入度减一)
            if (d[j] == 0) (知道这个点的入度为0，再把这个点加入到队列里面)
                q[++tt] = j;
        }
    }
    return tt == n - 1; (tt = n-1时才代表所有的点都被连起来了)
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;  (add一个a到b的点，即代表b的入度加一)
    }
    if (!topo())
        cout<<"-1"<<endl;
    else
    {
        for (int i = 0; i < n; i++)
            cout << q[i] << ' ';
        cout << endl;
    }
}

用STL队列做法：
要用一个队头的数组储存每一个出队的节点，top的序列就是拓扑序列。
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 100010;
int h[N], e[N], ne[N], idx, d[N], top[N];(d数组是存储每个点的入度情况，top就是一个队头的数组储存每一个出队的节点，top的序列就是拓扑序列)
int n, m;
queue<int> q;
void add(int a, int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}
bool topu()
{
	for (int i = 1; i <= n; i++)
		if (d[i] == 0)  (第一步先把入度为0的点先加到队列里面)
			q.push(i);
	int cnt = 0;		
	while (q.size())
	{
		auto t = q.front();
		top[cnt] = t;
		cnt++;
		q.pop();
		for (int i = h[t]; i != -1; i = ne[i])
		{
			int j = e[i];
			d[j]--; (这个是队头指向的节点，该节点的入度减一)
			if (d[j] == 0) (知道这个点的入度为0，再把这个点加入到队列里面)
			{
				q.push(j);
			}
		}
	}
	if (cnt < n) (cnt就是top数组中的元素个数，要等于n才代表是一个拓扑序列)
		return false;
	else
		return true;
}
int main()
{
	cin >> n >> m;
	memset(h, -1, sizeof(h));
	while (m--)
	{
		int a, b;
		cin >> a >> b;
		add(a, b);
		d[b]++; (add一个a到b的点，即代表b的入度加一)
	}
	if (topu())
	{
		for (int i = 0; i < n; i++)
			cout << top[i] << ' ';
	}
	else
		cout << "-1" << endl;
}


最短路问题：

最小生成树：是要把所要的点都串起来，而且最小生成树是求所有点连接起来最小的边权和，但是最短路是一个起点到终点的最短路径；
最短路：是求两点的最短路，不用把所有的点都穿起来

一.单源最短路
从一个点到其他所有点的最短距离。
单源可以分为两大类
1.所有边权都是正数：可以用 朴素的dijkstra算法 或者 堆优化版的dijkstra算法，朴素版用邻接矩阵存数据，堆优化用邻接表。邻接矩阵初始化为正无穷，
邻接表初始化表头为为-1。
朴素dijkstra算法： //（O(n^2)）
基础步骤模板：(用邻接矩阵做)
1.dist[1] = 0,dist[i] = 正无穷；
2.for i 1-n （因为是个矩阵，这一大步需要二重循环）
找到当前没有确定最短路的点当中，距离最小的那一个，把这个值赋给t
把t加到集合s中
拿t更新其他的点到起点的距离
模板题：
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。
请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。
输入格式
第一行包含整数 n 和 m。
接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。
输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。
如果路径不存在，则输出 −1。
数据范围
1≤n≤500,
1≤m≤105,
图中涉及边长均不超过10000。
输入样例：
3 3
1 2 2
2 3 1
1 3 4
输出样例：
3
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 510;
int g[N][N], dist[N];
bool st[N];
int n, m;

int Dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 0; i < n; i++)
    {
        int t = -1;
        for (int j = 1; j <= n; j++)
            if ((t == -1 || dist[t] > dist[j]) && !st[j])
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    else
        return dist[n];
}
int main()
{
    cin >> n >> m;
    memset(g, 0x3f, sizeof(g));
    for (int i = 0; i < m; i++)
    {
        int x, y, z;
        cin >> x >> y >> z;
        g[x][y] = min(g[x][y], z);
    }
    int t = Dijkstra();
    cout << t << endl;
}
堆优化版本的做法(优先队列)： O(mlogn)m是边数
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 150010;
int h[N], idx, val[N], ne[N], w[N], dist[N];
int n, m, x, y, z;
bool st[N];
void add(int x, int y, int z)//(邻接表的储存方式，邻接表存储的是点的下标，边权是由w数组储存)
{
    w[idx] = z;
    val[idx] = y;
    ne[idx] = h[x];
    h[x] = idx;
    idx++;
}
int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> q;//(要用小顶堆储存)
    q.push({0,1});  (这个优先队列第一个元素是当前节点到起点的距离，也就是dist，第二个元素是当前节点的编号)
    while (q.size())
    {
        auto t = q.top(); (每次拿堆顶，也就是距离最小值的点去更新其他所有的点)
        q.pop();
        int num = t.second, distance = t.first;
        if (st[num])
            continue;
        st[num] = true;
        for (int i = h[num]; i != -1; i = ne[i])
        {
            int j = val[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                q.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    else
        return dist[n];
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++)
    {
        cin >> x >> y >> z;
        add(x, y, z);
    }
    cout << dijkstra() << endl;
}

例题： (此题是要遍历所有的点然后求得最短路，也就是要遍历所有的最短路然后求其最大值即是答案)
战争时期，前线有 n 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。
信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。
指挥部设在第一个哨所。
当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信。
当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计。
直至所有 n 个哨所全部接到命令后，送信才算成功。
因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。
现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。
输入格式
第 1 行有两个整数 n 和 m，中间用 1 个空格隔开，分别表示有 n 个哨所和 m 条通信线路。
第 2 至 m+1 行：每行三个整数 i、j、k，中间用 1 个空格隔开，表示第 i 个和第 j 个哨所之间存在 双向 通信线路，且这条线路要花费 k 天。
输出格式
一个整数，表示完成整个送信过程的最短时间。
如果不是所有的哨所都能收到信，就输出-1。
数据范围
1≤n≤100,
1≤m≤200,
1≤k≤1000
输入样例：
4 4
1 2 4
2 3 7
2 4 1
3 4 6
输出样例：
11

AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
const int INF = 0x3f3f3f3f;
typedef long long ll;
const int N = 110;
int h[N], ne[N * 2], e[N * 2], idx;
int dist[N];
int w[N];
bool st[N];
int n, m;
void add(int a, int b, int c)
{
    w[idx] = c;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> q;
    q.push({0, 1});
    while (q.size())
    {
        auto t = q.top();
        q.pop();
        int num = t.second, distance = t.first;
        if (st[num])
            continue;
        st[num] = true;
        for (int i = h[num]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > w[i] + distance)
            {
                dist[j] = w[i] + distance;
                q.push({dist[j], j});
            }
        }
    }
    int ans = -INF;
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    else
        {
         for(int i = 1;i<=n;i++)
         ans = max(dist[i],ans);
         return ans;
        }
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }
    cout << dijkstra() << endl;
}
2.存在某些边权重是负数：可以用 Bellman-ford 或者 SPFA
bellman-ford：
for n次
  for 所有的边 a,b,w (从a点到b点，边长权重为w)
       dist[b] = min(dist[b],dist[a] + w)
模板题：
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。
请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。
注意：图中可能 存在负权回路 。
输入格式
第一行包含三个整数 n,m,k。
接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。
输出格式
输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。
如果不存在满足条件的路径，则输出 impossible。
数据范围
1≤n,k≤500,
1≤m≤10000,
任意边长的绝对值不超过 10000。
输入样例：
3 3 1
1 2 1
2 3 1
1 3 3
输出样例：
3
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 510, M = 10010;
int dist[N], pre[N];
int n, m, k;
int x, y, z;
struct edge
{
    int a, b, w;
} edges[M];
int bellman_ford()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 0; i < k; i++)
    {
        memcpy(pre, dist, sizeof(dist));//这个是备份，防止发生串联，保证在更新数据数据时用的是上一次迭代的结果，
        //不然不能保证一定是至多k条边。
        for (int j = 0; j < m; j++)
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[b], pre[a] + w);
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2)
        return -1;
    else
        return dist[n];
}
int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < m; i++)
    {
        cin >> x >> y >> z;
        edges[i] = {x, y, z};
    }
    int ans = bellman_ford();
    if (ans == -1 && m != 1)
        cout << "impossible" << endl;
    else
        cout << ans << endl;
}

SPFA： (用的最多的)
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 100010;
int h[N], e[N], ne[N], idx, dist[N], w[N];
int n, m;
bool st[N];(判断这个数使用过没有，其实不用开这个布尔数组答案也对，但是有的恶心的题目会让你TLE)
void add(int a, int b, int c)
{
    w[idx] = c;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int spfa()  (每次用队头的元素去更新dist数组中的数值，松弛后出队换下一个)
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false; (因为t从队列出去了，所以要把t这个点重置为false)
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if(!st[j])
                {
                q.push(j);
                st[j] = true;
                }
            }
        }
    }
        return dist[n];
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b, w;
        cin >> a >> b >> w;
        add(a, b, w);
    }
       if (spfa() == 0x3f3f3f3f)
        cout << "impossible" << endl;
    else
        cout << spfa() << endl;
}
spfa判断是否存在负环：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 2010, M = 10010;
int h[N], e[M], ne[M], idx, dist[N], w[M], cnt[N]; (多加了一个cnt数组，用来记录边数，如果cnt>=n，则至少存在一个负环，一定至少有两个点的
值相等)
int n, m;
bool st[N];
void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}
int spfa()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    queue<int> q;
    for (int i = 1; i <= n; i++) (因为判断负环不是说从第一个点到第几个点，所以要把所有的点加到队列里面，因为有可能有的负环第一个点走不到)
    {
        st[i] = true;
        q.push(i);
    }
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1; (对边数数组的更新)
                if (!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
                if (cnt[j] >= n)
                    return true;
            }
        }
    }
    return false;
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    if (spfa())
        cout << "Yes" << endl;
    else
        cout << "No" << endl;
}
二.多源汇最短路：Floyd算法
起点和终点不确定随机，求最短路。
Floyd算法的本质是动态规划，其转移方程 为：f[k][i][j] = min( f[k-1][i][j], f([k-1][i] [k])+f[k-1][k][j] )。
模板题：
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。
再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible。
数据保证图中不存在负权回路。
输入格式
第一行包含三个整数 n,m,k。
接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。
接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。
输出格式
共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。
数据范围
1≤n≤200,
1≤k≤n2
1≤m≤20000,
图中涉及边长绝对值均不超过 10000。
输入样例：
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3

AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 210;
int n, m, k, Q;
int g[N][N]; //这个数组的理解要根据动态规划去理解，g[i][j]表示i到j的最短路
void floyd() (背住就可以，这个是动态规划推出来的式子，具体看这个https://www.acwing.com/solution/content/49316/)
{
    for (int k = 1; k <= n; k++)  //从i出发，只经过1->k个中间点到达j
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]); //其实原本是g[k][i][j],表示从i出发，只经过1->k个中间点到达j，但是k可以省去
}
int main()
{
    cin >> n >> m >> Q;
    memset(g, 0x3f, sizeof(g));
    for (int i = 1; i <= n; i++)
        g[i][i] = 0;
    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b], c);
    }
    floyd();
    for (int i = 1; i <= Q; i++)
    {
        int x, y;
        cin >> x >> y;
        int ans = g[x][y];
        if (ans >= 0x3f3f3f3f / 2)  //ans >= 0x3f3f3f3f / 2是因为可能存在负权边，导致即使没有答案ans也不一定等于正无穷
            cout << "impossible" << endl;
        else
            cout << ans << endl;
    }
}
灾后重建 (floyd好题，帮助理解) https://www.luogu.com.cn/problem/P1119
AC代码：
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 210;
const int INF = 0x3f3f3f3f;
int d[N][N], n, m, Q;
int day[N];
void floyd(int k) //因为不是所有的点都可以用，所以k不需要再一个循环
{
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> day[i];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
            if (i == j)
                d[i][j] = 0;
            else
                d[i][j] = INF;
        }
    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = c;
    }
    cin >> Q;
    int num = 0; // num是代表这个点可以用，把他扔进floyd更新其他的点
    while (Q--)
    {
        int a, b, t;
        cin >> a >> b >> t;
        while (num < n && day[num] <= t)
        {
            floyd(num);
            num++;
        }
        if (day[a] > t || day[b] > t)
            cout << "-1" << endl;
        else if (d[a][b] >= INF / 2)
            cout << "-1" << endl;
        else
            cout << d[a][b] << endl;
    }
}
最小生成树：

最小生成树：是要把所要的点都串起来，而且最小生成树是求所有点连接起来最小的边权和，但是最短路是一个起点到终点的最短路径；
最短路：是求两点的最短路，不用把所有的点都穿起来

对应的问题都为无向图。
如果是稠密图，大多是用朴素版的prim算法。(稠密图用邻接矩阵存，稀疏图用邻接表存)
如果是稀疏图，大多是kruskal算法。
prim的堆优化版本不是太常用。

算法：
1.prim算法(普利姆算法)
这玩意和dijkstra很像，dijkstra每次获取一个最小距离的点，prim每次获取一个距离最小的边。
1.dist[i] = 正无穷；
2.for i 1-n （因为是个矩阵，这一大步需要二重循环）
找到当前没有确定最短路的点当中，距离最小的那一个，把这个值赋给t
把t加到集合s中
拿t更新其他的点到 集合(这是唯一一个prim和dijkstra算法不同的步骤) 的距离。
模板题：
给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。
求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。
给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。
由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。
输入格式
第一行包含两个整数 n 和 m。
接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。
输出格式
共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。
数据范围
1≤n≤500,
1≤m≤105,
图中涉及边的边权的绝对值均不超过 10000。
输入样例：
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
输出样例：
6
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int N = 510, INF = 0x3f3f3f3f;
int dist[N], g[N][N];
int n, m;
bool st[N];

int prim()
{
    memset(dist, 0x3f, sizeof(dist));
    int ans = 0;
    for (int i = 0; i < n; i++)
    {
        int t = -1;
        for (int j = 1; j <= n; j++)
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        }
        if (i && dist[t] == INF) (如果上面一层循环之后dist[t]到集合内点的距离为正无穷，即代表图不连通也就是无法生成最小树)
            return INF;
        if (i)
            ans = ans + dist[t]; (更新边权)
        for (int j = 1; j <= n; j++)
        {
            dist[j] = min(dist[j], g[t][j]); (这里就是和dijkstra算法的不同的表现，g[t][j]就是点到集合任一点的最小距离而不是到起点的距离)
        }
        st[t] = true;
    }
    return ans;
}
int main()
{
    cin >> n >> m;
    memset(g, 0x3f, sizeof(g));
    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    int t = prim();
    if (t == 0x3f3f3f3f)
        cout << "impossible" << endl;
    else
        cout << t << endl;
}

2.kruskal算法(克鲁斯卡尔算法)
步骤：
1.将所有边按照权重从小到大排序
2.枚举每条边a，b权重c (for循环)
      if a b 不连通
          将这条边加入集合
模板题：
给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。
求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。
给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。
由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。
输入格式
第一行包含两个整数 n 和 m。
接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。
输出格式
共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。
数据范围
1≤n≤105,
1≤m≤2∗105,
图中涉及边的边权的绝对值均不超过 1000。
输入样例：
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
输出样例：
6
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 200010;
int fa[N], n, m;
class point
{
public:
    int a, b, c;
} p[N];
bool cmp(point &m, point &n)
{
    return m.c < n.c;
}
int find(int x)
{
    if (fa[x] != x)
        fa[x] = find(fa[x]);
    return fa[x];
}
int main()
{
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        fa[i] = i;
    }
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        p[i] = {a, b, c};
    }
    sort(p, p + m, cmp);
    int cnt = 0, ans = 0;  (cnt是记录边数的，ans就是最小生成树边权的总和)
    for (int i = 0; i < m; i++)
    {
        int a = p[i].a, b = p[i].b, c = p[i].c;
        if (find(a) != find(b))
        {
            fa[find(a)] = find(b);
            cnt++;
            ans += c;
        }
    }
    if (cnt < n - 1)
        cout << "impossible" << endl;
    else
        cout << ans << endl;
}

二分图：
把一个图的顶点划分为两个不相交子集 ，使得每一条边都分别连接两个集合中的顶点。如果存在这样的划分，则此图为一个二分图。二分图不存在奇数环
顾名思义就是能分成两个部分的图
要注意的是，‘分’的是点并且这两个集合（这里我们称作X集合和Y集合）内部所有的点之间没有边相连，也就是说X集合中任何两点之间都不会有边相
连，Y亦然

匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点

最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。

完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。显然，完美匹配一定是最大匹配（完美
匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。

算法：
1.染色法 (https://www.acwing.com/solution/content/5281/)这个地址有dfs和bfs的做法，写的很好。
染色法的实质是判断一个图是不是二分图

染色法判定 (说白了就是把二分图看作两个集合，每个集合都是一种颜色，如果都是一个颜色的集合之间只要有一条线，则代表不是二分图，换做邻
接表来理解的话，就是说相邻的节点的颜色不能相同，相同则不是二分图)
如果一个图是连通的，可以用如下的染色法判定是否二分图：
1、我们把X部的结点颜色设为0，Y部的颜色设为1。
2、从某个未染色的结点u开始，做BFS或者DFS 。
3、把u染为0，枚举u的儿子v。如果v未染色，就染为与u相反的颜色，如果已染色，则判断u与v的颜色是否相同，相同则不是二分图。
4、如果一个图不连通，则在每个连通块中作判定。

模板题：
给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。
请你判断这个图是否是二分图。
输入格式
第一行包含两个整数 n 和 m。
接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。
输出格式
如果给定图是二分图，则输出 Yes，否则输出 No。
数据范围
1≤n,m≤105
输入样例：
4 4
1 3
1 4
2 3
2 4
输出样例：
Yes

AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 100010, M = 200010;
int idx, h[N], e[M], ne[M];
int color[N];
int n, m;
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
bool dfs(int u, int c)
{
    color[u] = c; (把当前节点的颜色染为参数c)
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i]; (当前节点下标)
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) (这里两种颜色分别是1和2，所以颜色是1的话就给下一个染上2，是2就给下一个染上1)
            {
                return false;
            }
        }
        else if (color[j] == c) (代表相邻节点的颜色和当前节点一样，所以一定是错的。)
            return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    bool flag = true; (利用flag表示是不是有矛盾发生)
    for (int i = 1; i <= n; i++)
    {
        if (!color[i])
        {
            if (!dfs(i, 1)) (如果有矛盾，参数1是代表深度优先遍历染成1的颜色)
            {
                flag = false;
                break;
            }
        }
    }
    if (flag == false)
        cout << "No" << endl;
    else
        cout << "Yes" << endl;
}
2.匈牙利算法 (匹配数量最大)
返回成功匹配当中匹配成功数量最大的。匹配成功就是二分图的基本概念，能分成两个集合。
主要思想拿男女生来举例子，男生和女生匹配，如果男生B喜欢的女生A已经和男生A之前匹配了，那么找找男生A有没有还能匹配的女生，如果有，男生A
就去和另一个女生匹配，那么男生B就能和女生A匹配了

模板题：
给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。
数据保证任意一条边的两个端点都不可能在同一部分中。
请你求出二分图的最大匹配数。
二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。
二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。
输入格式
第一行包含三个整数 n1、 n2 和 m。
接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。
输出格式
输出一个整数，表示二分图的最大匹配数。
数据范围
1≤n1,n2≤500,
1≤u≤n1,
1≤v≤n2,
1≤m≤105
输入样例：
2 2 4
1 1
1 2
2 1
2 2
输出样例：
2
AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 510, M = 100010;
int match[N]; (女生匹配的男生，match[i]就是妹子i匹配的男生)
bool st[N]; (男生有没有找过某个女生)
int e[M], ne[M], h[N], idx;

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool find(int x) (整个函数都是对当前x这个男生判断)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) (如果这个男生没有找过这个女生当作对象，一个男生最多考虑一个女生一次)
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j])) (有两种情况情况，第一种是这个女生是单身还没有匹配男生，第二种情况是这个女生有匹配对象了，但是
这个女生匹配的男生有第三者，也就是有下家可以去找。换句话说，如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功
,更新match)
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false; //自己中意的全部都被预定了。配对失败
}
int main()
{
    int n1, n2, m;
    cin >> n1 >> n2 >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b); (这里只加一条边是因为这里只对男生判断，就是对一个集合判断)
    }
    int ans = 0; (最大匹配数)
    for (int i = 1; i <= n1; i++)
    {
        memset(st, false, sizeof(st)); ( (整个函数都是对当前i这个男生判断，所以男生i找对象时所有妹子都没有考虑过))
        if (find(i))
            ans++;
    }
    cout << ans << endl;
}

ST表：
基础应用：ST表是一种基于倍增思想，用于解决可重复贡献问题(就是对于同一个问题有多个不同的询问，没办法用单调队列之类的因为单调队列只询问
一次)的数据结构。

ST表应用最广泛的领域便是解决RMQ问题：给定n个数，m个询问，对于每个询问，需要回答区间[l,r]中的最大值或
最小值(可以采用两个数组同时进行处理)。(是静态的，数据不会改变)
d[i][j]代表这样一段区间的最值：左端点为i，长度为2^j，也就意味着，他管辖了[i,i+2^j-1]。
1<<i == 2^i 位运算
主要公示的推导：
st[0][1]是下标为0~1的最小值，自然也就是st[0][0]和st[1][0]的最值
以此往下类推我们可以得出结论：
st[i][j] = min(st[i][j - 1],st[i + 2^(j - 1))][j - 1])
比如说log(4)=2,log(5)=2,log(6)=2,log(7)=2,log(8)=3,log(9)=3……. 
那么我们要查询x到y的最小值。 
设len=y-x+1,t=log(len) 
根据上面的定理：2^t>len/2 
从位置上来说，x+2^t越过了x到y的中间！ 
因为位置过了一半 
所以x到y的最小值可以表示为min(从x往后2^t的最小值，从y往前2^t的最小值) 
前面的状态表示为mn[t][x] 
设后面（从y往前2^t的最小值）的初始位置是k， 
那么k+2^t-1=y，所以k=y-2^t+1 
所以后面的状态表示为mn[t][y-2^t+1] 
所以x到y的最小值表示为min(mn[t][x],mn[t][y-2^t+1])，所以查询时间复杂度是O（1）

查询函数：查询区间的最大值，最小值的话直接max改成min就可以了
1 int search(int l, int r)
2 {
3     int k = (int)(log((double)(r - l + 1)) / log(2.0));
4     return min(st[l][k],st[r - (1 << k) + 1][k]);
5 }
模板：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 100010;
int st[N][20], a[N];
int n, m;
int l, r;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}
int main()
{
    n = read(), m = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 1; i <= n; i++)
        st[i][0] = a[i];
    for (int j = 1; j <= 20; j++)
        for (int i = 1; i <= n; i++)
            if (i + (1 << j) - 1 <= N)
                st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    for (int i = 1; i <= m; i++)
    {
        l = read(), r = read();
        int k = (int)(log((double)(r - l + 1)) / log(2.0));
        printf("%d\n", max(st[l][k], st[r - (1 << k) + 1][k]));
    }
}
LCA问题： 
在一个有根树，给两个点，求他们两个点最近的祖先，成为他们的最近公共祖先，这就是LCA要求的问题。
1.向上标记法：
时间复杂度O(n);
2.倍增法：
fa[i,j]表示从i开始，向上走2^j步所能走到的节点。
j = 0 fa[i,j] = i的父节点
j > 0  fa[i,j] = f[f[i,j - 1],[j-1]];可以用递推实现。
depth[i]表示深度
哨兵：如果从i开始跳2^j步会跳过根节点，那么fa[i,j] = 0,depth[0] = 0
步骤：
1.先将两个点跳到同一层
2.让两个点同时往上跳，直到一直跳到他们的最近公共祖先的下一层。

模板题：
给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 1∼n。

有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。

输入格式
输入第一行包括一个整数 表示节点个数；

接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −1，那么 a 就是树的根；

第 n+2 行是一个整数 m 表示询问个数；

接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。

输出格式
对于每一个询问，若 x 是 y 的祖先则输出 1，若 y 是 x 的祖先则输出 2，否则输出 0。

数据范围
1≤n,m≤4×104,
1≤每个节点的编号≤4×104
输入样例：
10
234 -1
12 234
13 234
14 234
15 234
16 234
17 234
18 234
19 234
233 19
5
234 233
233 12
233 13
233 15
233 19
输出样例：
1
0
0
0
2

AC：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 40010, M = N * 2;
int e[M], ne[M], h[N], idx;
int n, m;
int depth[N];
int fa[N][16];
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
void bfs(int u) (处理depth数组和fa数组)
{
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0; (这两步就是放置哨兵)
    depth[u] = 1;
    queue<int> q;
    q.push(u);
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q.push(j);
                fa[j][0] = t;   (j = 0时的情况)
                for (int k = 1; k <= 15; k++)  (j不等于0的情况，先走2^(j-1)再走2^(j-1))
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}
int lca(int a, int b)
{
    if (depth[a] > depth[b]) (保证b在a的下面，也就是b比a深)
        swap(a, b);
    for (int k = 15; k >= 0; k--)
    {
        if (depth[fa[b][k]] >= depth[a]) (这就是第一步，把b往上走直到和a在同一层)
            b = fa[b][k];
    }
    if (a == b)  (如果a和b直接重合了，则返回a或者b都可以)
        return b;
    for (int k = 15; k >= 0; k--) (因为a和b已经在同一层了，这步循环就是a和b一起往上走直到a和b在他们最近公共祖先的下一层)
    {
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    }
    return fa[b][0]; (这个意思就是b往上走一格，就是返回b和a的最近公共祖先)
}
int main()
{
    cin >> n;
    int root = 0;
    memset(h, -1, sizeof(h));
    while (n--)
    {
        int a, b;
        cin >> a >> b;
        if (b == -1)
            root = a;
        else
        {
            add(a, b);
            add(b, a);
        }
    }
    bfs(root);
    cin >> m;
    for (int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        int ans = lca(x, y);
        if (ans == x)
            cout << "1" << endl;
        else if (ans == y)
            cout << "2" << endl;
        else
            cout << "0" << endl;
    }
}

树状数组：
1.可以快速求前缀和
2.修改某一个数           （都是logn）


线段树：线段树是一种可以快速进行区间修改和区间查询的数据结构(logn)
线段树是用数组来模拟树形结构，对于每一个节点R ,左子节点为 2*R (一般写作R<<1)右子节点为 2*R+1（一般写作R<<1|1）
主要有两个操作：
1.pushup：由子节点算父节点的信息
2.pushdown：将父节点的修改信息下传到子节点
基本操作：
1.pushup
2.build ： 将一段区间初始化成线段树
3.modify：修改某一个单点或者某一个区间(修改区间就是pushdown)
4.query：查询某一段区间的操作
线段树开空间的时候正常要开4n的点！！！
build操作伪代码：
bulid(int u,int L,int R) （u代表递归到某一个节点，记住线段树分成的每个子区间都可以看作是一个节点，那个接点里面有左区间和右区间以及该节点区
间的最大值）
{
     tr[n].L = L,tr[n].R = R;
     if(L==R)
       return;
     int mid = L+R>>1;
     build(u<<1,L,mid),build(u<<1|1,mid+1,R);
}
单点修改：
模板题：
给定一个正整数数列 a1,a2,…,an，每一个数都在 0∼p−1 之间。

可以对这列数进行两种操作：

添加操作：向序列后添加一个数，序列长度变成 n+1；
询问操作：询问这个序列中最后 L 个数中最大的数是多少。
程序运行的最开始，整数序列为空。

一共要对整数序列进行 m 次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

输入格式
第一行有两个正整数 m,p，意义如题目描述；

接下来 m 行，每一行表示一个操作。

如果该行的内容是 Q L，则表示这个操作是询问序列中最后 L 个数的最大数是多少；

如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。

第一个操作一定是添加操作。对于询问操作，L>0 且不超过当前序列的长度。

输出格式
对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 L 个数的最大数。

数据范围
1≤m≤2×105,
1≤p≤2×109,
0≤t<p
输入样例：
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
输出样例：
97
97
97
60
60
97

AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 200010, M = N * 2;
int m, p;
struct node //每一个节点有三个属性，左端点，右端点，v是这个节点的最大值
{
    int l, r;
    int v;
} tree[N * 4];
void bulid(int u, int l, int r) //知道一个节点之后，建立其左儿子和右儿子
{
    if (l == r) //l==r就代表已经递归到叶子节点了，所以返回
        return;
    int mid = l + r >> 1; //建树不用考虑mid和区间的关系，直接建树就可以了
    bulid(u << 1, l, mid);
    bulid(u << 1 | 1, mid + 1, r);
}
void pushup(int u)//拿左儿子和右儿子更新父亲节点的最大值
{
    tree[u].v = max(tree[u << 1].v, tree[u << 1 | 1].v);
}
int query(int u, int l, int r)////查询的过程是从根结点开始往下找对应的一个区间
{
    if (tree[u].l >= l && tree[u].r <= r) //代表要查询到的节点左右端点值已经在题目要查询的l和r之间，即返回当前节点的最大值
        return tree[u].v;
    int mid = tree[u].l + tree[u].r >> 1;
    int v = 0;
    if (mid >= l) (mid >= l则代表当前节点的区间一定和查询区间的左节点有交集，所以继续找目前节点的左儿子)
        v = query(u << 1, l, r);//记住，查询的后两个参数一定是l和r，因为要找到l和r之间的最大值，从左子树开始找，记录v值，然后下面再和右子树
//最大值比
    if (mid < r) （mid < r则代表当前节点的区间一定和查询区间的右节点有交集，所以继续找目前节点的右儿子)
        v = max(v, query(u << 1 | 1, l, r));
    return v;
}
void modify(int u, int x, int v) //就是找到叶子节点修改，第一个参数也就是当前节点的编号,第二个参数是要修改的位置，第三个参数是要修改的值
{
    if (tree[u].l == x && tree[u].r == x)
        tree[u].v = v;
    else
    {
        int mid = tree[u].l + tree[u].r >> 1;
        if (x <= mid)
            modify(u << 1, x, v);
        else
            modify(u << 1 | 1, x, v);
        pushup(u); //记住这里要pushup操作，你修改完数据后要更新节点的最大值
    }
}
int main()
{
    cin >> m >> p;
    bulid(1, 1, m);
    char a;
    int cnt = 0, n = 0; (cnt是记录上一个的查找答案，n是代表整个线段树的元素数量)
    while (m--)
    {
        int x;
        cin >> a;
        if (a == 'Q')
        {
            cin >> x;
            cnt = query(1, n - x + 1, n);
            cout << cnt << endl;
        }
        else
        {
            cin >> x;
            modify(1, n + 1, (ll(cnt) + x) % p);
            n++;
        }
    }
}
区间修改：
模板题：
计算区间和，修改区间。
AC代码：
#include <bits/stdc++.h>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 100010;
int n, m;
int w[N];
struct Node
{
    int l, r;
    ll sum, add;
}tree[N * 4];
void pushup(int u)
{
    tree[u].sum = tree[u << 1].sum + tree[u << 1 | 1].sum; // pushup用子节点更新父节点的信息
}
void pushdown(int u) //传递懒标记给子节点，记得在每次分裂的时候(就是算mid的时候，除了建树)都要pushdown一下
{
    auto &root = tree[u], &left = tree[u << 1], &right = tree[u << 1 | 1]; //记得取地址符
    if (root.add) // 代表根节点还有懒标记，代表懒标记还没有传递下去
    {
        left.add += root.add, left.sum += (ll)(left.r - left.l + 1) * root.add;
        right.add += root.add, right.sum += (ll)(right.r - right.l + 1) * root.add;
        root.add = 0; //！！！这里要记得把根节点的懒标记归0，代表已经传递了
    }
}
void build(int u, int l, int r)
{
    if (l == r) //找到叶节点，这里一定要是l == r，不能是tree[u].l == tree[u].r,不然会报错，因为每次遍历的左右区间相同才代表找到叶节点
    {
        tree[u].sum = w[r];
        tree[u].l = l;
        tree[u].r = r;
        tree[u].add = 0;
    }
    else
    {
        tree[u] = {l,r};
        int mid = l + r >> 1; //这里不用判断mid和区间的关系，直接左右建树就可以
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int d)
{
    if (tree[u].l >= l && tree[u].r <= r)
    {
        tree[u].sum += (ll)(tree[u].r - tree[u].l + 1) * d;
        tree[u].add += d;
    }
    else
    {
        pushdown(u);
        int mid = tree[u].l + tree[u].r >> 1;
        if (l <= mid)
            modify(u << 1, l, r, d);
        if (r > mid)
            modify(u << 1 | 1, l, r, d);
        pushup(u); //修改完要更新下父节点的信息
    }
}
ll qurey(int u, int l, int r)
{
    if (tree[u].l >= l && tree[u].r <= r)
        return tree[u].sum;
    pushdown(u); //重要！！！这里push的作用是你在mid分裂前一定要先把懒标记传递下去，
    //不然有可能会造成错误，比如左半边加10但是右半边可能加15，具体题目具体分析，有的线段树题不用加
    int mid = tree[u].l + tree[u].r >> 1;
    ll sum = 0;
    if (l <= mid)
        sum = qurey(u << 1, l, r);
    if(r > mid)
        sum += qurey(u << 1 | 1, l, r);
    return sum;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        scanf("%d", &w[i]);
    build(1, 1, n);
    char a;
    int l, r, d;
    while (m--)
    {
        cin >> a;
        if (a == 'Q')
        {
            cin >> l >> r;
            printf("%lld\n",qurey(1,l,r));
        }
        else
        {
            cin >> l >> r >> d;
            modify(1, l, r, d);
        }
    }
}
扫描线：

数论：
1.判断质数
试除法：
#include<iostream>
using namespace std;
bool is_prime(int &x)
{
    if(x<2)
    return false;
    for(int i = 2;i<=x/i;i++) (这里的i<=x/i是一个优化，试处法的时间复杂度一定是根号n)
    {
        if(x%i==0)
        return false;
    }
    return true;
}
int main()
{
    int n,x;
    cin>>n;
    while(n--)
    {
        cin>>x;
        if(is_prime(x))
        cout<<"Yes"<<endl;
        else
        cout<<"No"<<endl;
    }
}

分解质因数：
#include <iostream>
using namespace std;
void is_prime(int x)
{
    for(int i = 2;i<=x/i;i++)
    {
        if(x%i == 0)  //保证此时的i一定是质因数，因为在2-i-1的数全部都剔除了
        {
            int s = 0;
            while(x%i == 0)
            {
                x/=i;
                s++;
            }
            cout<<i<<' '<<s<<endl;
        }
    }
    if(x>1)  //剩下的就是大于根号n的质因子，单独考虑
    cout<<x<<' '<<'1'<<endl;
    cout<<endl;
}
int main()
{
    int n,x;
    cin>>n;
    while(n--)
    {
        cin>>x;
        is_prime(x);
    }
}

2.约数
试除法求约数
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
vector<int> get_divisor(int x)
{
    vector<int> ans;
    for(int i = 1;i<=x/i;i++)
    {
        if(x%i == 0)
        {
            ans.push_back(i);
            if(i != x/i)
            ans.push_back(x/i);
        }
    }
    sort(ans.begin(),ans.end());
    return ans;
}
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int x;
        cin>>x;
        vector<int> a = get_divisor(x);
        for(auto t : a)  (auto t就相当于正常循环中的int i)
        cout<<t<<' ';
        cout<<endl;
    }
}

求组合数：
给定 n 组询问，每组询问给定两个整数 a，b，请你输出 Cbamod(109+7) 的值。

输入格式
第一行包含整数 n。

接下来 n 行，每行包含一组 a 和 b。

输出格式
共 n 行，每行输出一个询问的解。

数据范围
1≤n≤10000,
1≤b≤a≤2000
输入样例：
3
3 1
5 3
2 2
输出样例：
3
10
1
AC代码：
#include <iostream>
using namespace std;
const int N = 2010,mod = 1e9+7;
int c[N][N];
void init()
{
    for(int i = 0;i<N;i++)
    for(int j = 0;j<=i;j++)
    if(!j)c[i][j] = 1;
    else
    c[i][j] = (c[i-1][j]+c[i-1][j-1])%mod; (该公式的推导具体看ipad，说白了就是dp中的第i个数选与不选的区别)
}
int main(){
    int n;
    cin>>n;
    init();
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        cout<<c[a][b]<<endl;
    }
}


